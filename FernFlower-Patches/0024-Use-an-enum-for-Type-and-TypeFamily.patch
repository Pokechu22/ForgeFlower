From 19d80d6a757b26ac396e0e93e6bde9c909b917b7 Mon Sep 17 00:00:00 2001
From: Pokechu22 <Pokechu022@gmail.com>
Date: Sat, 4 Aug 2018 23:33:59 -0700
Subject: [PATCH] Use an enum for Type and TypeFamily


diff --git a/src/org/jetbrains/java/decompiler/code/CodeConstants.java b/src/org/jetbrains/java/decompiler/code/CodeConstants.java
index 3166c6e..9339c16 100644
--- a/src/org/jetbrains/java/decompiler/code/CodeConstants.java
+++ b/src/org/jetbrains/java/decompiler/code/CodeConstants.java
@@ -1,6 +1,9 @@
 // Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.code;
 
+import java.util.HashMap;
+import java.util.Map;
+
 @SuppressWarnings({"unused", "SpellCheckingInspection"})
 public interface CodeConstants {
   // ----------------------------------------------------------------------
@@ -18,37 +21,98 @@ public interface CodeConstants {
   // VARIABLE TYPES
   // ----------------------------------------------------------------------
 
-  int TYPE_BYTE = 0;
-  int TYPE_CHAR = 1;
-  int TYPE_DOUBLE = 2;
-  int TYPE_FLOAT = 3;
-  int TYPE_INT = 4;
-  int TYPE_LONG = 5;
-  int TYPE_SHORT = 6;
-  int TYPE_BOOLEAN = 7;
-  int TYPE_OBJECT = 8;
-  int TYPE_ADDRESS = 9;
-  int TYPE_VOID = 10;
-  int TYPE_ANY = 11;
-  int TYPE_GROUP2EMPTY = 12;
-  int TYPE_NULL = 13;
-  int TYPE_NOTINITIALIZED = 14;
-  int TYPE_BYTECHAR = 15;
-  int TYPE_SHORTCHAR = 16;
-  int TYPE_UNKNOWN = 17;
-  int TYPE_GENVAR = 18;
+  enum Type {
+    BYTE('B', TypeFamily.INTEGER, "byte", "java/lang/Byte"),
+    CHAR('C', TypeFamily.INTEGER, "char", "java/lang/Character"),
+    DOUBLE('D', TypeFamily.DOUBLE, "double", "java/lang/Double"),
+    FLOAT('F', TypeFamily.FLOAT, "float", "java/lang/Float"),
+    INT('I', TypeFamily.INTEGER, "int", "java/lang/Integer"),
+    LONG('J', TypeFamily.LONG, "long", "java/lang/Long"),
+    SHORT('S', TypeFamily.INTEGER, "short", "java/lang/Short"),
+    BOOLEAN('Z', TypeFamily.BOOLEAN, "boolean", "java/lang/Boolean"),
+    OBJECT(null, TypeFamily.OBJECT),
+    ADDRESS('A', TypeFamily.UNKNOWN),
+    VOID('V', TypeFamily.UNKNOWN, "void", null),
+    ANY(null, TypeFamily.UNKNOWN) {
+      @Override
+      public String getDescriptor() {
+        throw new RuntimeException("Invalid type");
+      }
+    },
+    GROUP2EMPTY('G', TypeFamily.UNKNOWN),
+    NULL(null, TypeFamily.OBJECT),
+    NOTINITIALIZED('N', TypeFamily.UNKNOWN),
+    BYTECHAR('X', TypeFamily.INTEGER, null, "java/lang/Byte"),
+    SHORTCHAR('Y', TypeFamily.INTEGER, null, "java/lang/Short"),
+    UNKNOWN('U', TypeFamily.UNKNOWN),
+    GENVAR(null, TypeFamily.UNKNOWN) {
+      @Override
+      public String getDescriptor() {
+        throw new RuntimeException("Invalid type");
+      }
+    };
+
+    private Type(Character symbol, TypeFamily family) {
+      this(symbol, family, null, null);
+    }
+
+    private Type(Character symbol, TypeFamily family, String keyword, String boxedClass) {
+      this.symbol = symbol;
+      this.descriptor = (symbol != null) ? symbol.toString() : null;
+      this.family = family;
+      this.keyword = keyword;
+      this.boxedClass = boxedClass;
+    }
+
+    private final TypeFamily family;
+    // May be null
+    private final Character symbol;
+    private final String descriptor;
+    private final String keyword;
+    private final String boxedClass;
+
+    public TypeFamily getFamily() {
+      return family;
+    }
+    public String getDescriptor() {
+      return descriptor;
+    }
+    public String getKeyword() {
+      return keyword;
+    }
+    public String getBoxedClass() {
+      return boxedClass;
+    }
+
+    private static final Map<Character, Type> BY_SYMBOL = new HashMap<>();
+    static {
+      for (Type type : values()) {
+        if (type.symbol != null) {
+          BY_SYMBOL.put(type.symbol, type);
+        }
+      }
+    }
+    public static Type forSymbol(char c) {
+      if (BY_SYMBOL.containsKey(c)) {
+        return BY_SYMBOL.get(c);
+      }
+      throw new IllegalArgumentException("Invalid type: " + c);
+    }
+  }
 
   // ----------------------------------------------------------------------
   // VARIABLE TYPE FAMILIES
   // ----------------------------------------------------------------------
 
-  int TYPE_FAMILY_UNKNOWN = 0;
-  int TYPE_FAMILY_BOOLEAN = 1;
-  int TYPE_FAMILY_INTEGER = 2;
-  int TYPE_FAMILY_FLOAT = 3;
-  int TYPE_FAMILY_LONG = 4;
-  int TYPE_FAMILY_DOUBLE = 5;
-  int TYPE_FAMILY_OBJECT = 6;
+  enum TypeFamily {
+    UNKNOWN,
+    BOOLEAN,
+    INTEGER,
+    FLOAT,
+    LONG,
+    DOUBLE,
+    OBJECT;
+  }
 
   // ----------------------------------------------------------------------
   // ACCESS FLAGS
diff --git a/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java b/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java
index 3c6b14d..4212801 100644
--- a/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java
+++ b/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java
@@ -695,7 +695,7 @@ public class ControlFlowGraph implements CodeConstants {
           break;
         case CodeConstants.opc_astore:
         case CodeConstants.opc_pop:
-          if (var.type == CodeConstants.TYPE_ADDRESS) {
+          if (var.type == CodeConstants.Type.ADDRESS) {
             seq.removeInstruction(i);
             i--;
           }
@@ -717,7 +717,7 @@ public class ControlFlowGraph implements CodeConstants {
 
         DataPoint point = new DataPoint();
         point.setLocalVariables(new ArrayList<>(data.getLocalVariables()));
-        point.getStack().push(new VarType(CodeConstants.TYPE_OBJECT, 0, null));
+        point.getStack().push(new VarType(CodeConstants.Type.OBJECT, 0, null));
 
         removeJsrInstructions(pool, suc, point);
       }
diff --git a/src/org/jetbrains/java/decompiler/code/interpreter/InstructionImpact.java b/src/org/jetbrains/java/decompiler/code/interpreter/InstructionImpact.java
index 5c56593..ae76738 100644
--- a/src/org/jetbrains/java/decompiler/code/interpreter/InstructionImpact.java
+++ b/src/org/jetbrains/java/decompiler/code/interpreter/InstructionImpact.java
@@ -15,7 +15,7 @@ import org.jetbrains.java.decompiler.util.ListStack;
 public class InstructionImpact {
 
   // {read, write}
-  private static final int[][][] stack_impact = {
+  private static final CodeConstants.Type[][][] stack_impact = {
 
     {null, null},                                                //		public final static int		opc_nop = 0;
     null,                                                                //		public final static int		opc_aconst_null = 1;
@@ -26,22 +26,22 @@ public class InstructionImpact {
     null,                        //		public final static int		opc_iconst_3 = 6;
     null,                        //		public final static int		opc_iconst_4 = 7;
     null,                        //		public final static int		opc_iconst_5 = 8;
-    {null, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_lconst_0 = 9;
-    {null, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_lconst_1 = 10;
-    {null, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_fconst_0 = 11;
-    {null, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_fconst_1 = 12;
-    {null, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_fconst_2 = 13;
-    {null, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_dconst_0 = 14;
-    {null, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_dconst_1 = 15;
-    {null, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_bipush = 16;
-    {null, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_sipush = 17;
+    {null, {CodeConstants.Type.LONG}},                        //		public final static int		opc_lconst_0 = 9;
+    {null, {CodeConstants.Type.LONG}},                        //		public final static int		opc_lconst_1 = 10;
+    {null, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_fconst_0 = 11;
+    {null, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_fconst_1 = 12;
+    {null, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_fconst_2 = 13;
+    {null, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_dconst_0 = 14;
+    {null, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_dconst_1 = 15;
+    {null, {CodeConstants.Type.INT}},                        //		public final static int		opc_bipush = 16;
+    {null, {CodeConstants.Type.INT}},                        //		public final static int		opc_sipush = 17;
     null,                        //		public final static int		opc_ldc = 18;
     null,                        //		public final static int		opc_ldc_w = 19;
     null,                        //		public final static int		opc_ldc2_w = 20;
-    {null, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_iload = 21;
-    {null, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_lload = 22;
-    {null, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_fload = 23;
-    {null, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_dload = 24;
+    {null, {CodeConstants.Type.INT}},                        //		public final static int		opc_iload = 21;
+    {null, {CodeConstants.Type.LONG}},                        //		public final static int		opc_lload = 22;
+    {null, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_fload = 23;
+    {null, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_dload = 24;
     null,                        //		public final static int		opc_aload = 25;
     null,                        //		public final static int		opc_iload_0 = 26;
     null,                        //		public final static int		opc_iload_1 = 27;
@@ -63,25 +63,25 @@ public class InstructionImpact {
     null,                        //		public final static int		opc_aload_1 = 43;
     null,                        //		public final static int		opc_aload_2 = 44;
     null,                        //		public final static int		opc_aload_3 = 45;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_iaload = 46;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_laload = 47;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_faload = 48;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_daload = 49;
     null,                        //		public final static int		opc_aaload = 50;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_baload = 51;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_caload = 52;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_saload = 53;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_istore = 54;
-    {{CodeConstants.TYPE_LONG}, null},                        //		public final static int		opc_lstore = 55;
-    {{CodeConstants.TYPE_FLOAT}, null},                        //		public final static int		opc_fstore = 56;
-    {{CodeConstants.TYPE_DOUBLE}, null},                        //		public final static int		opc_dstore = 57;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_istore = 54;
+    {{CodeConstants.Type.LONG}, null},                        //		public final static int		opc_lstore = 55;
+    {{CodeConstants.Type.FLOAT}, null},                        //		public final static int		opc_fstore = 56;
+    {{CodeConstants.Type.DOUBLE}, null},                        //		public final static int		opc_dstore = 57;
     null,                        //		public final static int		opc_astore = 58;
     null,                        //		public final static int		opc_istore_0 = 59;
     null,                        //		public final static int		opc_istore_1 = 60;
@@ -103,24 +103,24 @@ public class InstructionImpact {
     null,                        //		public final static int		opc_astore_1 = 76;
     null,                        //		public final static int		opc_astore_2 = 77;
     null,                        //		public final static int		opc_astore_3 = 78;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.INT}, null},
     //		public final static int		opc_iastore = 79;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_LONG}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.LONG}, null},
     //		public final static int		opc_lastore = 80;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_FLOAT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.FLOAT}, null},
     //		public final static int		opc_fastore = 81;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_DOUBLE}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.DOUBLE}, null},
     //		public final static int		opc_dastore = 82;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_OBJECT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.OBJECT}, null},
     //		public final static int		opc_aastore = 83;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.INT}, null},
     //		public final static int		opc_bastore = 84;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.INT}, null},
     //		public final static int		opc_castore = 85;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.INT, CodeConstants.Type.INT}, null},
     //		public final static int		opc_sastore = 86;
-    {{CodeConstants.TYPE_ANY}, null},                        //		public final static int		opc_pop = 87;
-    {{CodeConstants.TYPE_ANY, CodeConstants.TYPE_ANY}, null},                        //		public final static int		opc_pop2 = 88;
+    {{CodeConstants.Type.ANY}, null},                        //		public final static int		opc_pop = 87;
+    {{CodeConstants.Type.ANY, CodeConstants.Type.ANY}, null},                        //		public final static int		opc_pop2 = 88;
     null,                        //		public final static int		opc_dup = 89;
     null,                        //		public final static int		opc_dup_x1 = 90;
     null,                        //		public final static int		opc_dup_x2 = 91;
@@ -128,126 +128,126 @@ public class InstructionImpact {
     null,                        //		public final static int		opc_dup2_x1 = 93;
     null,                        //		public final static int		opc_dup2_x2 = 94;
     null,                        //		public final static int		opc_swap = 95;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_iadd = 96;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_ladd = 97;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_fadd = 98;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_dadd = 99;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_isub = 100;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lsub = 101;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_fsub = 102;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_dsub = 103;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_imul = 104;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lmul = 105;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_fmul = 106;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_dmul = 107;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_idiv = 108;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_ldiv = 109;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_fdiv = 110;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_ddiv = 111;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_irem = 112;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lrem = 113;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},
     //		public final static int		opc_frem = 114;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},
     //		public final static int		opc_drem = 115;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_ineg = 116;
-    {{CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_lneg = 117;
-    {{CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_fneg = 118;
-    {{CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_dneg = 119;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_ineg = 116;
+    {{CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},                        //		public final static int		opc_lneg = 117;
+    {{CodeConstants.Type.FLOAT}, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_fneg = 118;
+    {{CodeConstants.Type.DOUBLE}, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_dneg = 119;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_ishl = 120;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.INT}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lshl = 121;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_ishr = 122;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.INT}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lshr = 123;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_iushr = 124;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.INT}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lushr = 125;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_iand = 126;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_land = 127;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_ior = 128;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lor = 129;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_ixor = 130;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_LONG}},
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.LONG}},
     //		public final static int		opc_lxor = 131;
     {null, null},                        //		public final static int		opc_iinc = 132;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_i2l = 133;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_i2f = 134;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_i2d = 135;
-    {{CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_l2i = 136;
-    {{CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_l2f = 137;
-    {{CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_l2d = 138;
-    {{CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_f2i = 139;
-    {{CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_f2l = 140;
-    {{CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_DOUBLE}},                        //		public final static int		opc_f2d = 141;
-    {{CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_d2i = 142;
-    {{CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_LONG}},                        //		public final static int		opc_d2l = 143;
-    {{CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_FLOAT}},                        //		public final static int		opc_d2f = 144;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_i2b = 145;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_i2c = 146;
-    {{CodeConstants.TYPE_INT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_i2s = 147;
-    {{CodeConstants.TYPE_LONG, CodeConstants.TYPE_LONG}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.LONG}},                        //		public final static int		opc_i2l = 133;
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_i2f = 134;
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_i2d = 135;
+    {{CodeConstants.Type.LONG}, {CodeConstants.Type.INT}},                        //		public final static int		opc_l2i = 136;
+    {{CodeConstants.Type.LONG}, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_l2f = 137;
+    {{CodeConstants.Type.LONG}, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_l2d = 138;
+    {{CodeConstants.Type.FLOAT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_f2i = 139;
+    {{CodeConstants.Type.FLOAT}, {CodeConstants.Type.LONG}},                        //		public final static int		opc_f2l = 140;
+    {{CodeConstants.Type.FLOAT}, {CodeConstants.Type.DOUBLE}},                        //		public final static int		opc_f2d = 141;
+    {{CodeConstants.Type.DOUBLE}, {CodeConstants.Type.INT}},                        //		public final static int		opc_d2i = 142;
+    {{CodeConstants.Type.DOUBLE}, {CodeConstants.Type.LONG}},                        //		public final static int		opc_d2l = 143;
+    {{CodeConstants.Type.DOUBLE}, {CodeConstants.Type.FLOAT}},                        //		public final static int		opc_d2f = 144;
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_i2b = 145;
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_i2c = 146;
+    {{CodeConstants.Type.INT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_i2s = 147;
+    {{CodeConstants.Type.LONG, CodeConstants.Type.LONG}, {CodeConstants.Type.INT}},
     //		public final static int		opc_lcmp = 148;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_fcmpl = 149;
-    {{CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_FLOAT}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.FLOAT, CodeConstants.Type.FLOAT}, {CodeConstants.Type.INT}},
     //		public final static int		opc_fcmpg = 150;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.INT}},
     //		public final static int		opc_dcmpl = 151;
-    {{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_DOUBLE}, {CodeConstants.TYPE_INT}},
+    {{CodeConstants.Type.DOUBLE, CodeConstants.Type.DOUBLE}, {CodeConstants.Type.INT}},
     //		public final static int		opc_dcmpg = 152;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ifeq = 153;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ifne = 154;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_iflt = 155;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ifge = 156;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ifgt = 157;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ifle = 158;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmpeq = 159;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmpne = 160;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmplt = 161;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmpge = 162;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmpgt = 163;
-    {{CodeConstants.TYPE_INT, CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_if_icmple = 164;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_OBJECT}, null},
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ifeq = 153;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ifne = 154;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_iflt = 155;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ifge = 156;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ifgt = 157;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ifle = 158;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmpeq = 159;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmpne = 160;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmplt = 161;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmpge = 162;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmpgt = 163;
+    {{CodeConstants.Type.INT, CodeConstants.Type.INT}, null},                        //		public final static int		opc_if_icmple = 164;
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.OBJECT}, null},
     //		public final static int		opc_if_acmpeq = 165;
-    {{CodeConstants.TYPE_OBJECT, CodeConstants.TYPE_OBJECT}, null},
+    {{CodeConstants.Type.OBJECT, CodeConstants.Type.OBJECT}, null},
     //		public final static int		opc_if_acmpne = 166;
     {null, null},                        //		public final static int		opc_goto = 167;
-    {null, {CodeConstants.TYPE_ADDRESS}},                        //		public final static int		opc_jsr = 168;
+    {null, {CodeConstants.Type.ADDRESS}},                        //		public final static int		opc_jsr = 168;
     {null, null},                        //		public final static int		opc_ret = 169;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_tableswitch = 170;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_lookupswitch = 171;
-    {{CodeConstants.TYPE_INT}, null},                        //		public final static int		opc_ireturn = 172;
-    {{CodeConstants.TYPE_LONG}, null},                        //		public final static int		opc_lreturn = 173;
-    {{CodeConstants.TYPE_FLOAT}, null},                        //		public final static int		opc_freturn = 174;
-    {{CodeConstants.TYPE_DOUBLE}, null},                        //		public final static int		opc_dreturn = 175;
-    {{CodeConstants.TYPE_OBJECT}, null},                        //		public final static int		opc_areturn = 176;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_tableswitch = 170;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_lookupswitch = 171;
+    {{CodeConstants.Type.INT}, null},                        //		public final static int		opc_ireturn = 172;
+    {{CodeConstants.Type.LONG}, null},                        //		public final static int		opc_lreturn = 173;
+    {{CodeConstants.Type.FLOAT}, null},                        //		public final static int		opc_freturn = 174;
+    {{CodeConstants.Type.DOUBLE}, null},                        //		public final static int		opc_dreturn = 175;
+    {{CodeConstants.Type.OBJECT}, null},                        //		public final static int		opc_areturn = 176;
     {null, null},                        //		public final static int		opc_return = 177;
     null,                        //		public final static int		opc_getstatic = 178;
     null,                        //		public final static int		opc_putstatic = 179;
@@ -261,34 +261,34 @@ public class InstructionImpact {
     null,                        //		public final static int		opc_new = 187;
     null,                        //		public final static int		opc_newarray = 188;
     null,                        //		public final static int		opc_anewarray = 189;
-    {{CodeConstants.TYPE_OBJECT}, {CodeConstants.TYPE_INT}},                        //		public final static int		opc_arraylength = 190;
+    {{CodeConstants.Type.OBJECT}, {CodeConstants.Type.INT}},                        //		public final static int		opc_arraylength = 190;
     null,
     //		public final static int		opc_athrow = 191;
     null,
     //		public final static int		opc_checkcast = 192;
     null,
     //		public final static int		opc_instanceof = 193;
-    {{CodeConstants.TYPE_OBJECT}, null},                                //		public final static int		opc_monitorenter = 194;
-    {{CodeConstants.TYPE_OBJECT}, null},                                //		public final static int		opc_monitorexit = 195;
+    {{CodeConstants.Type.OBJECT}, null},                                //		public final static int		opc_monitorenter = 194;
+    {{CodeConstants.Type.OBJECT}, null},                                //		public final static int		opc_monitorexit = 195;
     null,
     //		public final static int		opc_wide = 196;
     null,
     //		public final static int		opc_multianewarray = 197;
-    {{CodeConstants.TYPE_OBJECT}, null},                                //		public final static int		opc_ifnull = 198;
-    {{CodeConstants.TYPE_OBJECT}, null},                                //		public final static int		opc_ifnonnull = 199;
+    {{CodeConstants.Type.OBJECT}, null},                                //		public final static int		opc_ifnull = 198;
+    {{CodeConstants.Type.OBJECT}, null},                                //		public final static int		opc_ifnonnull = 199;
     {null, null},                                                                        //		public final static int		opc_goto_w = 200;
-    {null, {CodeConstants.TYPE_ADDRESS}},                        //		public final static int		opc_jsr_w = 201;
+    {null, {CodeConstants.Type.ADDRESS}},                        //		public final static int		opc_jsr_w = 201;
   };
 
-  private static final int[] arr_type = new int[]{
-    CodeConstants.TYPE_BOOLEAN,
-    CodeConstants.TYPE_CHAR,
-    CodeConstants.TYPE_FLOAT,
-    CodeConstants.TYPE_DOUBLE,
-    CodeConstants.TYPE_BYTE,
-    CodeConstants.TYPE_SHORT,
-    CodeConstants.TYPE_INT,
-    CodeConstants.TYPE_LONG
+  private static final CodeConstants.Type[] arr_type = {
+    CodeConstants.Type.BOOLEAN,
+    CodeConstants.Type.CHAR,
+    CodeConstants.Type.FLOAT,
+    CodeConstants.Type.DOUBLE,
+    CodeConstants.Type.BYTE,
+    CodeConstants.Type.SHORT,
+    CodeConstants.Type.INT,
+    CodeConstants.Type.LONG
   };
 
 
@@ -326,20 +326,20 @@ public class InstructionImpact {
 
   public static void stepTypes(DataPoint data, Instruction instr, ConstantPool pool) {
     ListStack<VarType> stack = data.getStack();
-    int[][] arr = stack_impact[instr.opcode];
+    CodeConstants.Type[][] arr = stack_impact[instr.opcode];
 
     if (arr != null) {
       // simple types only
 
-      int[] read = arr[0];
-      int[] write = arr[1];
+      CodeConstants.Type[] read = arr[0];
+      CodeConstants.Type[] write = arr[1];
 
       if (read != null) {
         int depth = 0;
-        for (int type : read) {
+        for (CodeConstants.Type type : read) {
           depth++;
-          if (type == CodeConstants.TYPE_LONG ||
-              type == CodeConstants.TYPE_DOUBLE) {
+          if (type == CodeConstants.Type.LONG ||
+              type == CodeConstants.Type.DOUBLE) {
             depth++;
           }
         }
@@ -348,11 +348,11 @@ public class InstructionImpact {
       }
 
       if (write != null) {
-        for (int type : write) {
+        for (CodeConstants.Type type : write) {
           stack.push(new VarType(type));
-          if (type == CodeConstants.TYPE_LONG ||
-              type == CodeConstants.TYPE_DOUBLE) {
-            stack.push(new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+          if (type == CodeConstants.Type.LONG ||
+              type == CodeConstants.Type.DOUBLE) {
+            stack.push(new VarType(CodeConstants.Type.GROUP2EMPTY));
           }
         }
       }
@@ -373,7 +373,7 @@ public class InstructionImpact {
 
     switch (instr.opcode) {
       case CodeConstants.opc_aconst_null:
-        stack.push(new VarType(CodeConstants.TYPE_NULL, 0, null));
+        stack.push(new VarType(CodeConstants.Type.NULL, 0, null));
         break;
       case CodeConstants.opc_ldc:
       case CodeConstants.opc_ldc_w:
@@ -381,24 +381,24 @@ public class InstructionImpact {
         PooledConstant constant = pool.getConstant(instr.operand(0));
         switch (constant.type) {
           case CodeConstants.CONSTANT_Integer:
-            stack.push(new VarType(CodeConstants.TYPE_INT));
+            stack.push(new VarType(CodeConstants.Type.INT));
             break;
           case CodeConstants.CONSTANT_Float:
-            stack.push(new VarType(CodeConstants.TYPE_FLOAT));
+            stack.push(new VarType(CodeConstants.Type.FLOAT));
             break;
           case CodeConstants.CONSTANT_Long:
-            stack.push(new VarType(CodeConstants.TYPE_LONG));
-            stack.push(new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+            stack.push(new VarType(CodeConstants.Type.LONG));
+            stack.push(new VarType(CodeConstants.Type.GROUP2EMPTY));
             break;
           case CodeConstants.CONSTANT_Double:
-            stack.push(new VarType(CodeConstants.TYPE_DOUBLE));
-            stack.push(new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+            stack.push(new VarType(CodeConstants.Type.DOUBLE));
+            stack.push(new VarType(CodeConstants.Type.GROUP2EMPTY));
             break;
           case CodeConstants.CONSTANT_String:
-            stack.push(new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/String"));
+            stack.push(new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/String"));
             break;
           case CodeConstants.CONSTANT_Class:
-            stack.push(new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Class"));
+            stack.push(new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Class"));
             break;
           case CodeConstants.CONSTANT_MethodHandle:
             stack.push(new VarType(((LinkConstant)constant).descriptor));
@@ -411,7 +411,7 @@ public class InstructionImpact {
           stack.push(var1);
         }
         else {
-          stack.push(new VarType(CodeConstants.TYPE_OBJECT, 0, null));
+          stack.push(new VarType(CodeConstants.Type.OBJECT, 0, null));
         }
         break;
       case CodeConstants.opc_aaload:
@@ -445,7 +445,7 @@ public class InstructionImpact {
         var1 = new VarType(ck.descriptor);
         stack.push(var1);
         if (var1.stackSize == 2) {
-          stack.push(new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+          stack.push(new VarType(CodeConstants.Type.GROUP2EMPTY));
         }
         break;
       case CodeConstants.opc_putfield:
@@ -467,17 +467,17 @@ public class InstructionImpact {
           for (int i = 0; i < md.params.length; i++) {
             stack.pop(md.params[i].stackSize);
           }
-          if (md.ret.type != CodeConstants.TYPE_VOID) {
+          if (md.ret.type != CodeConstants.Type.VOID) {
             stack.push(md.ret);
             if (md.ret.stackSize == 2) {
-              stack.push(new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+              stack.push(new VarType(CodeConstants.Type.GROUP2EMPTY));
             }
           }
         }
         break;
       case CodeConstants.opc_new:
         cn = pool.getPrimitiveConstant(instr.operand(0));
-        stack.push(new VarType(CodeConstants.TYPE_OBJECT, 0, cn.getString()));
+        stack.push(new VarType(CodeConstants.Type.OBJECT, 0, cn.getString()));
         break;
       case CodeConstants.opc_newarray:
         stack.pop();
@@ -492,7 +492,7 @@ public class InstructionImpact {
       case CodeConstants.opc_instanceof:
         stack.pop();
         cn = pool.getPrimitiveConstant(instr.operand(0));
-        stack.push(new VarType(CodeConstants.TYPE_OBJECT, 0, cn.getString()));
+        stack.push(new VarType(CodeConstants.Type.OBJECT, 0, cn.getString()));
         break;
       case CodeConstants.opc_anewarray:
       case CodeConstants.opc_multianewarray:
@@ -500,12 +500,12 @@ public class InstructionImpact {
         stack.pop(dimensions);
         cn = pool.getPrimitiveConstant(instr.operand(0));
         if (cn.isArray) {
-          var1 = new VarType(CodeConstants.TYPE_OBJECT, 0, cn.getString());
+          var1 = new VarType(CodeConstants.Type.OBJECT, 0, cn.getString());
           var1 = var1.resizeArrayDim(var1.arrayDim + dimensions);
           stack.push(var1);
         }
         else {
-          stack.push(new VarType(CodeConstants.TYPE_OBJECT, dimensions, cn.getString()));
+          stack.push(new VarType(CodeConstants.Type.OBJECT, dimensions, cn.getString()));
         }
     }
   }
diff --git a/src/org/jetbrains/java/decompiler/main/AssertProcessor.java b/src/org/jetbrains/java/decompiler/main/AssertProcessor.java
index a5f8d72..397e944 100644
--- a/src/org/jetbrains/java/decompiler/main/AssertProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/AssertProcessor.java
@@ -23,7 +23,7 @@ import java.util.List;
 
 public class AssertProcessor {
 
-  private static final VarType CLASS_ASSERTION_ERROR = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/AssertionError");
+  private static final VarType CLASS_ASSERTION_ERROR = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/AssertionError");
 
   public static void buildAssertions(ClassNode node) {
 
diff --git a/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java b/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
index 42778d4..a441e85 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
@@ -42,7 +42,7 @@ public class ClassReference14Processor {
     ctor.setStringDescriptor("()V");
     ctor.setFunctype(InvocationExprent.TYP_INIT);
     ctor.setDescriptor(MethodDescriptor.parseDescriptor("()V"));
-    NewExprent newExpr = new NewExprent(new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/NoClassDefFoundError"), new ArrayList<>(), null);
+    NewExprent newExpr = new NewExprent(new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/NoClassDefFoundError"), new ArrayList<>(), null);
     newExpr.setConstructor(ctor);
     InvocationExprent invCause = new InvocationExprent();
     invCause.setName("initCause");
@@ -51,7 +51,7 @@ public class ClassReference14Processor {
     invCause.setDescriptor(MethodDescriptor.parseDescriptor("(Ljava/lang/Throwable;)Ljava/lang/Throwable;"));
     invCause.setInstance(newExpr);
     invCause.setLstParameters(
-      Collections.singletonList(new VarExprent(2, new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/ClassNotFoundException"), null)));
+      Collections.singletonList(new VarExprent(2, new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/ClassNotFoundException"), null)));
     HANDLER_EXPR = new ExitExprent(ExitExprent.EXIT_THROW, invCause, null, null, null);
   }
 
@@ -137,7 +137,7 @@ public class ClassReference14Processor {
           CatchStatement cst = (CatchStatement)root.getFirst();
           if (cst.getStats().size() == 2 && cst.getFirst().type == Statement.TYPE_BASICBLOCK &&
               cst.getStats().get(1).type == Statement.TYPE_BASICBLOCK &&
-              cst.getVars().get(0).getVarType().equals(new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/ClassNotFoundException"))) {
+              cst.getVars().get(0).getVarType().equals(new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/ClassNotFoundException"))) {
 
             BasicBlockStatement body = (BasicBlockStatement)cst.getFirst();
             BasicBlockStatement handler = (BasicBlockStatement)cst.getStats().get(1);
diff --git a/src/org/jetbrains/java/decompiler/main/InitializerProcessor.java b/src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
index 373ccea..9753afb 100644
--- a/src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
@@ -104,7 +104,7 @@ public class InitializerProcessor {
             boolean invalidArguments = invExpr.getLstParameters().isEmpty();
 
             for (VarType type : invExpr.getDescriptor().params) {
-              if (type.type == CodeConstants.TYPE_OBJECT) {
+              if (type.type == CodeConstants.Type.OBJECT) {
                 ClassNode node = DecompilerContext.getClassProcessor().getMapRootClasses().get(type.value);
                 //TODO? Instead of nuking entire thing, just nuke the one parameter?
                 if (node != null && (node.type == ClassNode.CLASS_ANONYMOUS || (node.access & CodeConstants.ACC_SYNTHETIC) != 0)) {
@@ -134,7 +134,7 @@ public class InitializerProcessor {
         MethodDescriptor md = MethodDescriptor.parseDescriptor(desc);
         if (md.params.length > 0) {
           VarType type = md.params[md.params.length - 1];
-          if (type.type == CodeConstants.TYPE_OBJECT) {
+          if (type.type == CodeConstants.Type.OBJECT) {
             ClassNode node = DecompilerContext.getClassProcessor().getMapRootClasses().get(type.value);
             if (node != null && (node.type == ClassNode.CLASS_ANONYMOUS) || (node.access & CodeConstants.ACC_SYNTHETIC) != 0) {
               //TODO: Verify that the body is JUST a this([args]) call?
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index 4b4c3e9..a65be17 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -136,7 +136,7 @@ public class NestedClassProcessor {
       FieldExprent mapField = (FieldExprent)ass.getLeft();
       NewExprent _new = ((NewExprent)ass.getRight());
       if (!mapField.getClassname().equals(node.classStruct.qualifiedName) || !potentialFields.contains(mapField.getName()) ||
-          _new.getNewType().type != CodeConstants.TYPE_INT || _new.getNewType().arrayDim != 1 ||
+          _new.getNewType().type != CodeConstants.Type.INT || _new.getNewType().arrayDim != 1 ||
           _new.getLstDims().size() != 1 || _new.getLstDims().get(0).type != Exprent.EXPRENT_FUNCTION) {
         break;
       }
@@ -1056,7 +1056,7 @@ public class NestedClassProcessor {
           break;
         case Exprent.EXPRENT_NEW:
           VarType newType = ((NewExprent)expr).getNewType();
-          res = newType.type == CodeConstants.TYPE_OBJECT && classname.equals(newType.value);
+          res = newType.type == CodeConstants.Type.OBJECT && classname.equals(newType.value);
           break;
         case Exprent.EXPRENT_VAR:
           VarExprent varExpr = (VarExprent)expr;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
index 5290152..4370df7 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
@@ -19,8 +19,8 @@ public class ConcatenationHelper {
   private static final String bufferClass = "java/lang/StringBuffer";
   private static final String stringClass = "java/lang/String";
 
-  private static final VarType builderType = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/StringBuilder");
-  private static final VarType bufferType = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/StringBuffer");
+  private static final VarType builderType = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/StringBuilder");
+  private static final VarType bufferType = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/StringBuffer");
 
 
   public static Exprent contractStringConcat(Exprent expr) {
@@ -191,17 +191,17 @@ public class ConcatenationHelper {
       if (md.ret.equals(cltype) && md.params.length == 1) {
         VarType param = md.params[0];
         switch (param.type) {
-          case CodeConstants.TYPE_OBJECT:
+          case OBJECT:
             if (!param.equals(VarType.VARTYPE_STRING) &&
                 !param.equals(VarType.VARTYPE_OBJECT)) {
               break;
             }
-          case CodeConstants.TYPE_BOOLEAN:
-          case CodeConstants.TYPE_CHAR:
-          case CodeConstants.TYPE_DOUBLE:
-          case CodeConstants.TYPE_FLOAT:
-          case CodeConstants.TYPE_INT:
-          case CodeConstants.TYPE_LONG:
+          case BOOLEAN:
+          case CHAR:
+          case DOUBLE:
+          case FLOAT:
+          case INT:
+          case LONG:
             return true;
           default:
         }
@@ -229,17 +229,18 @@ public class ConcatenationHelper {
         if (md.params.length == 1) {
           VarType param = md.params[0];
           switch (param.type) {
-            case CodeConstants.TYPE_OBJECT:
+            case OBJECT:
               if (!param.equals(VarType.VARTYPE_OBJECT)) {
                 break;
               }
-            case CodeConstants.TYPE_BOOLEAN:
-            case CodeConstants.TYPE_CHAR:
-            case CodeConstants.TYPE_DOUBLE:
-            case CodeConstants.TYPE_FLOAT:
-            case CodeConstants.TYPE_INT:
-            case CodeConstants.TYPE_LONG:
+            case BOOLEAN:
+            case CHAR:
+            case DOUBLE:
+            case FLOAT:
+            case INT:
+            case LONG:
               return iex.getLstParameters().get(0);
+            default:
           }
         }
       }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index a3170fd..9b2146c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -27,7 +27,6 @@ import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.TextUtil;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 
 import java.util.*;
@@ -85,9 +84,9 @@ public class ExprProcessor implements CodeConstants {
   private static final int[] func7 = {IfExprent.IF_NULL, IfExprent.IF_NONNULL};
   private static final int[] func8 = {MonitorExprent.MONITOR_ENTER, MonitorExprent.MONITOR_EXIT};
 
-  private static final int[] arrTypeIds = {
-    CodeConstants.TYPE_BOOLEAN, CodeConstants.TYPE_CHAR, CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_DOUBLE,
-    CodeConstants.TYPE_BYTE, CodeConstants.TYPE_SHORT, CodeConstants.TYPE_INT, CodeConstants.TYPE_LONG
+  private static final CodeConstants.Type[] arrTypeIds = {
+    CodeConstants.Type.BOOLEAN, CodeConstants.Type.CHAR, CodeConstants.Type.FLOAT, CodeConstants.Type.DOUBLE,
+    CodeConstants.Type.BYTE, CodeConstants.Type.SHORT, CodeConstants.Type.INT, CodeConstants.Type.LONG
   };
 
   private static final int[] negIfs = {
@@ -96,8 +95,6 @@ public class ExprProcessor implements CodeConstants {
     IfExprent.IF_ICMPGT, IfExprent.IF_ACMPNE, IfExprent.IF_ACMPEQ
   };
 
-  private static final String[] typeNames = {"byte", "char", "double", "float", "int", "long", "short", "boolean"};
-
   private final MethodDescriptor methodDescriptor;
   private final VarProcessor varProcessor;
 
@@ -541,7 +538,7 @@ public class ExprProcessor implements CodeConstants {
             }
 
             InvocationExprent exprinv = new InvocationExprent(instr.opcode, invoke_constant, bootstrap_arguments, stack, bytecode_offsets);
-            if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
+            if (exprinv.getDescriptor().ret.type == CodeConstants.Type.VOID) {
               exprlist.add(exprinv);
             }
             else {
@@ -677,23 +674,20 @@ public class ExprProcessor implements CodeConstants {
   }
 
   public static String getTypeName(VarType type, boolean getShort) {
-    int tp = type.type;
-    if (tp <= CodeConstants.TYPE_BOOLEAN) {
-      return typeNames[tp];
+    CodeConstants.Type tp = type.type;
+    if (tp.getKeyword() != null) {
+      return tp.getKeyword();
     }
-    else if (tp == CodeConstants.TYPE_UNKNOWN) {
+    else if (tp == CodeConstants.Type.UNKNOWN) {
       return UNKNOWN_TYPE_STRING; // INFO: should not occur
     }
-    else if (tp == CodeConstants.TYPE_NULL) {
+    else if (tp == CodeConstants.Type.NULL) {
       return NULL_TYPE_STRING; // INFO: should not occur
     }
-    else if (tp == CodeConstants.TYPE_VOID) {
-      return "void";
-    }
-    else if (tp == CodeConstants.TYPE_GENVAR && type.isGeneric()) {
+    else if (tp == CodeConstants.Type.GENVAR && type.isGeneric()) {
       return type.value;
     }
-    else if (tp == CodeConstants.TYPE_OBJECT) {
+    else if (tp == CodeConstants.Type.OBJECT) {
       if (type.isGeneric()) {
         return ((GenericType)type).getCastName();
       }
@@ -840,16 +834,16 @@ public class ExprProcessor implements CodeConstants {
 
   public static ConstExprent getDefaultArrayValue(VarType arrType) {
     ConstExprent defaultVal;
-    if (arrType.type == CodeConstants.TYPE_OBJECT || arrType.arrayDim > 0) {
+    if (arrType.type == CodeConstants.Type.OBJECT || arrType.arrayDim > 0) {
       defaultVal = new ConstExprent(VarType.VARTYPE_NULL, null, null);
     }
-    else if (arrType.type == CodeConstants.TYPE_FLOAT) {
+    else if (arrType.type == CodeConstants.Type.FLOAT) {
       defaultVal = new ConstExprent(VarType.VARTYPE_FLOAT, 0f, null);
     }
-    else if (arrType.type == CodeConstants.TYPE_LONG) {
+    else if (arrType.type == CodeConstants.Type.LONG) {
       defaultVal = new ConstExprent(VarType.VARTYPE_LONG, 0L, null);
     }
-    else if (arrType.type == CodeConstants.TYPE_DOUBLE) {
+    else if (arrType.type == CodeConstants.Type.DOUBLE) {
       defaultVal = new ConstExprent(VarType.VARTYPE_DOUBLE, 0d, null);
     }
     else { // integer types
@@ -879,8 +873,8 @@ public class ExprProcessor implements CodeConstants {
 
     boolean cast =
       castAlways ||
-      (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) ||
-      (castNull && rightType.type == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType))) ||
+      (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.Type.OBJECT)) ||
+      (castNull && rightType.type == CodeConstants.Type.NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType))) ||
       (castNarrowing && isIntConstant(exprent) && isNarrowedIntType(leftType));
 
     boolean quote = cast && exprent.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST);
@@ -913,12 +907,13 @@ public class ExprProcessor implements CodeConstants {
   private static boolean isIntConstant(Exprent exprent) {
     if (exprent.type == Exprent.EXPRENT_CONST) {
       switch (((ConstExprent)exprent).getConstType().type) {
-        case CodeConstants.TYPE_BYTE:
-        case CodeConstants.TYPE_BYTECHAR:
-        case CodeConstants.TYPE_SHORT:
-        case CodeConstants.TYPE_SHORTCHAR:
-        case CodeConstants.TYPE_INT:
+        case BYTE:
+        case BYTECHAR:
+        case SHORT:
+        case SHORTCHAR:
+        case INT:
           return true;
+        default:
       }
     }
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java
index 4e26c7f..2f8ef96 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java
@@ -63,7 +63,7 @@ public class IdeaNotNullHelper {
         Exprent second_param = func.getLstOperands().get(1);
 
         if (second_param.type == Exprent.EXPRENT_CONST &&
-            second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+            second_param.getExprType().type == CodeConstants.Type.NULL) { // TODO: reversed parameter order
           if (first_param.type == Exprent.EXPRENT_VAR) {
             VarExprent var = (VarExprent)first_param;
 
@@ -201,7 +201,7 @@ public class IdeaNotNullHelper {
             Statement elsebranch = ifparent.getElsestat();
 
             if (second_param.type == Exprent.EXPRENT_CONST &&
-                second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+                second_param.getExprType().type == CodeConstants.Type.NULL) { // TODO: reversed parameter order
               //if(first_param.type == Exprent.EXPRENT_VAR && ((VarExprent)first_param).getIndex() == var_value.getIndex()) {
               if (first_param.equals(exprent_value)) {        // TODO: check for absence of side effects like method invocations etc.
                 if (ifbranch.type == Statement.TYPE_BASICBLOCK &&
@@ -265,7 +265,7 @@ public class IdeaNotNullHelper {
               Statement ifbranch = ifstat.getIfstat();
 
               if (second_param.type == Exprent.EXPRENT_CONST &&
-                  second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+                  second_param.getExprType().type == CodeConstants.Type.NULL) { // TODO: reversed parameter order
                 if (first_param.equals(exprent_value)) {        // TODO: check for absence of side effects like method invocations etc.
                   if (ifbranch.type == Statement.TYPE_BASICBLOCK &&
                       ifbranch.getExprents().size() == 1 &&
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/SecondaryFunctionsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/SecondaryFunctionsHelper.java
index a7c804b..a1d021c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/SecondaryFunctionsHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/SecondaryFunctionsHelper.java
@@ -204,10 +204,10 @@ public class SecondaryFunctionsHelper {
               VarType operandtype = operand.getExprType();
 
               if (operand.type == Exprent.EXPRENT_CONST &&
-                  operandtype.type != CodeConstants.TYPE_BOOLEAN) {
+                  operandtype.type != CodeConstants.Type.BOOLEAN) {
                 ConstExprent cexpr = (ConstExprent)operand;
                 long val;
-                if (operandtype.type == CodeConstants.TYPE_LONG) {
+                if (operandtype.type == CodeConstants.Type.LONG) {
                   val = (Long)cexpr.getValue();
                 }
                 else {
@@ -224,8 +224,8 @@ public class SecondaryFunctionsHelper {
             break;
           case FunctionExprent.FUNCTION_EQ:
           case FunctionExprent.FUNCTION_NE:
-            if (lstOperands.get(0).getExprType().type == CodeConstants.TYPE_BOOLEAN &&
-                lstOperands.get(1).getExprType().type == CodeConstants.TYPE_BOOLEAN) {
+            if (lstOperands.get(0).getExprType().type == CodeConstants.Type.BOOLEAN &&
+                lstOperands.get(1).getExprType().type == CodeConstants.Type.BOOLEAN) {
               for (int i = 0; i < 2; i++) {
                 if (lstOperands.get(i).type == Exprent.EXPRENT_CONST) {
                   ConstExprent cexpr = (ConstExprent)lstOperands.get(i);
@@ -263,8 +263,8 @@ public class SecondaryFunctionsHelper {
               ConstExprent cexpr1 = (ConstExprent)expr1;
               ConstExprent cexpr2 = (ConstExprent)expr2;
 
-              if (cexpr1.getExprType().type == CodeConstants.TYPE_BOOLEAN &&
-                  cexpr2.getExprType().type == CodeConstants.TYPE_BOOLEAN) {
+              if (cexpr1.getExprType().type == CodeConstants.Type.BOOLEAN &&
+                  cexpr2.getExprType().type == CodeConstants.Type.BOOLEAN) {
 
                 if (cexpr1.getIntValue() == 0 && cexpr2.getIntValue() != 0) {
                   return new FunctionExprent(FunctionExprent.FUNCTION_BOOL_NOT, lstOperands.get(0), fexpr.bytecode);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
index 2764c18..ecd0268 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
@@ -535,7 +535,7 @@ public class SimplifyExprentsHelper {
         VarType newType = newExpr.getNewType();
         VarVersionPair leftPair = new VarVersionPair((VarExprent)as.getLeft());
 
-        if (newType.type == CodeConstants.TYPE_OBJECT && newType.arrayDim == 0 && newExpr.getConstructor() == null) {
+        if (newType.type == CodeConstants.Type.OBJECT && newType.arrayDim == 0 && newExpr.getConstructor() == null) {
           for (int i = index + 1; i < list.size(); i++) {
             Exprent remote = list.get(i);
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
index c235387..0b8b297 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
@@ -281,7 +281,7 @@ public class StackVarsProcessor {
           // new Object(); permitted
           NewExprent nexpr = (NewExprent)right;
           if (nexpr.isAnonymous() || nexpr.getNewType().arrayDim > 0
-              || nexpr.getNewType().type != CodeConstants.TYPE_OBJECT) {
+              || nexpr.getNewType().type != CodeConstants.Type.OBJECT) {
             return new int[]{-1, changed};
           }
         }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
index 66f9eab..230b4a7 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
@@ -65,10 +65,10 @@ public class AssignmentExprent extends Exprent {
     VarType typeLeft = left.getExprType();
     VarType typeRight = right.getExprType();
 
-    if (typeLeft.typeFamily > typeRight.typeFamily) {
+    if (typeLeft.typeFamily.compareTo(typeRight.typeFamily) > 0) {
       result.addMinTypeExprent(right, VarType.getMinTypeInFamily(typeLeft.typeFamily));
     }
-    else if (typeLeft.typeFamily < typeRight.typeFamily) {
+    else if (typeLeft.typeFamily.compareTo(typeRight.typeFamily) < 0) {
       result.addMinTypeExprent(left, typeRight);
     }
     else {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
index cd08934..777832d 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
@@ -108,15 +108,15 @@ public class ConstExprent extends Exprent {
 
     tracer.addMapping(bytecode);
 
-    if (constType.type != CodeConstants.TYPE_NULL && value == null) {
+    if (constType.type != CodeConstants.Type.NULL && value == null) {
       return new TextBuffer(ExprProcessor.getCastTypeName(constType));
     }
 
     switch (constType.type) {
-      case CodeConstants.TYPE_BOOLEAN:
+      case BOOLEAN:
         return new TextBuffer(Boolean.toString((Integer)value != 0));
 
-      case CodeConstants.TYPE_CHAR:
+      case CHAR:
         Integer val = (Integer)value;
         String ret = CHAR_ESCAPES.get(val);
         if (ret == null) {
@@ -130,11 +130,11 @@ public class ConstExprent extends Exprent {
         }
         return new TextBuffer(ret).enclose("'", "'");
 
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_BYTECHAR:
-      case CodeConstants.TYPE_SHORT:
-      case CodeConstants.TYPE_SHORTCHAR:
-      case CodeConstants.TYPE_INT:
+      case BYTE:
+      case BYTECHAR:
+      case SHORT:
+      case SHORTCHAR:
+      case INT:
         int intVal = (Integer)value;
         if (!literal) {
           if (intVal == Integer.MAX_VALUE) {
@@ -146,7 +146,7 @@ public class ConstExprent extends Exprent {
         }
         return new TextBuffer(value.toString());
 
-      case CodeConstants.TYPE_LONG:
+      case LONG:
         long longVal = (Long)value;
         if (!literal) {
           if (longVal == Long.MAX_VALUE) {
@@ -158,7 +158,7 @@ public class ConstExprent extends Exprent {
         }
         return new TextBuffer(value.toString()).append('L');
 
-      case CodeConstants.TYPE_FLOAT:
+      case FLOAT:
         float floatVal = (Float)value;
         if (!literal) {
           if (Float.isNaN(floatVal)) {
@@ -188,7 +188,7 @@ public class ConstExprent extends Exprent {
         }
         return new TextBuffer(trimZeros(value.toString())).append('F');
 
-      case CodeConstants.TYPE_DOUBLE:
+      case DOUBLE:
         double doubleVal = (Double)value;
         if (!literal) {
           if (Double.isNaN(doubleVal)) {
@@ -218,10 +218,10 @@ public class ConstExprent extends Exprent {
         }
         return new TextBuffer(trimZeros(value.toString())).append('D');
 
-      case CodeConstants.TYPE_NULL:
+      case NULL:
         return new TextBuffer("null");
 
-      case CodeConstants.TYPE_OBJECT:
+      case OBJECT:
         if (constType.equals(VarType.VARTYPE_STRING)) {
           return new TextBuffer(convertStringToJava(value.toString(), ascii)).enclose("\"", "\"");
         }
@@ -230,9 +230,10 @@ public class ConstExprent extends Exprent {
           VarType type = new VarType(stringVal, !stringVal.startsWith("["));
           return new TextBuffer(ExprProcessor.getCastTypeName(type)).append(".class");
         }
-    }
 
-    throw new RuntimeException("invalid constant type: " + constType);
+      default:
+        throw new RuntimeException("invalid constant type: " + constType);
+    }
   }
   
   // Different JVM implementations/version display Floats and Doubles with different number of trailing zeros.
@@ -248,7 +249,7 @@ public class ConstExprent extends Exprent {
   }
 
   public boolean isNull() {
-    return CodeConstants.TYPE_NULL == constType.type;
+    return CodeConstants.Type.NULL == constType.type;
   }
 
   private static String convertStringToJava(String value, boolean ascii) {
@@ -313,54 +314,54 @@ public class ConstExprent extends Exprent {
 
   public boolean hasBooleanValue() {
     switch (constType.type) {
-      case CodeConstants.TYPE_BOOLEAN:
-      case CodeConstants.TYPE_CHAR:
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_BYTECHAR:
-      case CodeConstants.TYPE_SHORT:
-      case CodeConstants.TYPE_SHORTCHAR:
-      case CodeConstants.TYPE_INT:
+      case BOOLEAN:
+      case CHAR:
+      case BYTE:
+      case BYTECHAR:
+      case SHORT:
+      case SHORTCHAR:
+      case INT:
         int value = (Integer)this.value;
         return value == 0 || (DecompilerContext.getOption(IFernflowerPreferences.BOOLEAN_TRUE_ONE) && value == 1);
+      default:
+        return false;
     }
-
-    return false;
   }
 
   public boolean hasValueOne() {
     switch (constType.type) {
-      case CodeConstants.TYPE_BOOLEAN:
-      case CodeConstants.TYPE_CHAR:
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_BYTECHAR:
-      case CodeConstants.TYPE_SHORT:
-      case CodeConstants.TYPE_SHORTCHAR:
-      case CodeConstants.TYPE_INT:
+      case BOOLEAN:
+      case CHAR:
+      case BYTE:
+      case BYTECHAR:
+      case SHORT:
+      case SHORTCHAR:
+      case INT:
         return (Integer)value == 1;
-      case CodeConstants.TYPE_LONG:
+      case LONG:
         return ((Long)value).intValue() == 1;
-      case CodeConstants.TYPE_DOUBLE:
+      case DOUBLE:
         return ((Double)value).intValue() == 1;
-      case CodeConstants.TYPE_FLOAT:
+      case FLOAT:
         return ((Float)value).intValue() == 1;
+      default:
+        return false;
     }
-
-    return false;
   }
 
-  public static ConstExprent getZeroConstant(int type) {
+  public static ConstExprent getZeroConstant(CodeConstants.Type type) {
     switch (type) {
-      case CodeConstants.TYPE_INT:
+      case INT:
         return new ConstExprent(VarType.VARTYPE_INT, 0, null);
-      case CodeConstants.TYPE_LONG:
+      case LONG:
         return new ConstExprent(VarType.VARTYPE_LONG, 0L, null);
-      case CodeConstants.TYPE_DOUBLE:
+      case DOUBLE:
         return new ConstExprent(VarType.VARTYPE_DOUBLE, 0d, null);
-      case CodeConstants.TYPE_FLOAT:
+      case FLOAT:
         return new ConstExprent(VarType.VARTYPE_FLOAT, 0f, null);
+      default:
+        throw new RuntimeException("Invalid argument: " + type);
     }
-
-    throw new RuntimeException("Invalid argument: " + type);
   }
 
   public VarType getConstType() {
@@ -382,7 +383,7 @@ public class ConstExprent extends Exprent {
     }
     // BYTE, BYTECHAR, SHORTCHAR, SHORT, CHAR => INT in the INT context
     else if ((expectedType.equals(VarType.VARTYPE_INT) || expectedType.equals(VarType.VARTYPE_INTEGER)) &&
-            constType.typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
+            constType.typeFamily == CodeConstants.TypeFamily.INTEGER) {
       setConstType(VarType.VARTYPE_INT);
     }
   }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
index 2539299..cee101a 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
@@ -51,7 +51,7 @@ public class ExitExprent extends Exprent {
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
 
-    if (exitType == EXIT_RETURN && retType.type != CodeConstants.TYPE_VOID) {
+    if (exitType == EXIT_RETURN && retType.type != CodeConstants.Type.VOID) {
       result.addMinTypeExprent(value, VarType.getMinTypeInFamily(retType.typeFamily));
       result.addMaxTypeExprent(value, retType);
     }
@@ -75,7 +75,7 @@ public class ExitExprent extends Exprent {
     if (exitType == EXIT_RETURN) {
       TextBuffer buffer = new TextBuffer("return");
 
-      if (retType.type != CodeConstants.TYPE_VOID) {
+      if (retType.type != CodeConstants.Type.VOID) {
         VarType ret = retType;
         if (methodDescriptor != null && methodDescriptor.genericInfo != null && methodDescriptor.genericInfo.returnType != null) {
           ret = methodDescriptor.genericInfo.returnType;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
index 05d9d69..d6b7c71 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
@@ -260,7 +260,7 @@ public abstract class Exprent implements IMatchable {
   }
 
   protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int precedence) {
-    boolean needsCast = !left.isSuperset(right) && (right.equals(VarType.VARTYPE_OBJECT) || left.type != CodeConstants.TYPE_OBJECT);
+    boolean needsCast = !left.isSuperset(right) && (right.equals(VarType.VARTYPE_OBJECT) || left.type != CodeConstants.Type.OBJECT);
 
     if (left != null && left.isGeneric()) {
       Map<VarType, List<VarType>> names = this.getNamedGenerics();
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
index 9267f77..5a0f4ca 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
@@ -143,7 +143,7 @@ public class FieldExprent extends Exprent {
       }
       else {
         TextBuffer buff = new TextBuffer();
-        boolean casted = ExprProcessor.getCastedExprent(instance, new VarType(CodeConstants.TYPE_OBJECT, 0, classname), buff, indent, true, tracer);
+        boolean casted = ExprProcessor.getCastedExprent(instance, new VarType(CodeConstants.Type.OBJECT, 0, classname), buff, indent, true, tracer);
         String res = buff.toString();
 
         if (casted || instance.getPrecedence() > getPrecedence()) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
index bf30fd0..14f63c5 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
@@ -257,7 +257,7 @@ public class FunctionExprent extends Exprent {
         case FUNCTION_AND:
         case FUNCTION_OR:
         case FUNCTION_XOR:
-          if (type1.type == CodeConstants.TYPE_BOOLEAN & type2.type == CodeConstants.TYPE_BOOLEAN) {
+          if (type1.type == CodeConstants.Type.BOOLEAN & type2.type == CodeConstants.Type.BOOLEAN) {
             exprType = VarType.VARTYPE_BOOLEAN;
           }
           else {
@@ -273,7 +273,7 @@ public class FunctionExprent extends Exprent {
       Exprent param2 = lstOperands.get(2);
       VarType supertype = VarType.getCommonSupertype(param1.getExprType(), param2.getExprType());
       if (param1.type == Exprent.EXPRENT_CONST && param2.type == Exprent.EXPRENT_CONST &&
-          supertype.type != CodeConstants.TYPE_BOOLEAN && VarType.VARTYPE_INT.isSuperset(supertype)) {
+          supertype.type != CodeConstants.Type.BOOLEAN && VarType.VARTYPE_INT.isSuperset(supertype)) {
         exprType = VarType.VARTYPE_INT;
       }
       else {
@@ -328,11 +328,11 @@ public class FunctionExprent extends Exprent {
           }
         }
         else {
-            this.needsCast = right.type == CodeConstants.TYPE_NULL || !DecompilerContext.getStructContext().instanceOf(right.value, upperBound.value);
+            this.needsCast = right.type == CodeConstants.Type.NULL || !DecompilerContext.getStructContext().instanceOf(right.value, upperBound.value);
         }
       }
       else { //TODO: Capture generics to make cast better?
-        this.needsCast = right.type == CodeConstants.TYPE_NULL || !DecompilerContext.getStructContext().instanceOf(right.value, cast.value);
+        this.needsCast = right.type == CodeConstants.Type.NULL || !DecompilerContext.getStructContext().instanceOf(right.value, cast.value);
       }
     }
     return getExprType();
@@ -413,7 +413,7 @@ public class FunctionExprent extends Exprent {
       case FUNCTION_XOR:
       case FUNCTION_EQ:
       case FUNCTION_NE: {
-        if (type1.type == CodeConstants.TYPE_BOOLEAN) {
+        if (type1.type == CodeConstants.Type.BOOLEAN) {
           if (type2.isStrictSuperset(type1)) {
             result.addMinTypeExprent(param1, VarType.VARTYPE_BYTECHAR);
           }
@@ -429,7 +429,7 @@ public class FunctionExprent extends Exprent {
             }
           }
         }
-        else if (type2.type == CodeConstants.TYPE_BOOLEAN) {
+        else if (type2.type == CodeConstants.Type.BOOLEAN) {
           if (type1.isStrictSuperset(type2)) {
             result.addMinTypeExprent(param2, VarType.VARTYPE_BYTECHAR);
           }
@@ -616,7 +616,7 @@ public class FunctionExprent extends Exprent {
   }
 
   private static VarType getMaxVarType(VarType[] arr) {
-    int[] types = new int[]{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_LONG};
+    CodeConstants.Type[] types = {CodeConstants.Type.DOUBLE, CodeConstants.Type.FLOAT, CodeConstants.Type.LONG};
     VarType[] vartypes = new VarType[]{VarType.VARTYPE_DOUBLE, VarType.VARTYPE_FLOAT, VarType.VARTYPE_LONG};
 
     for (int i = 0; i < types.length; i++) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index a2906b1..ca4b622 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -329,7 +329,7 @@ public class InvocationExprent extends Exprent {
           TextBuffer res = instance.toJava(indent, tracer);
 
           VarType rightType = instance.getExprType();
-          VarType leftType = new VarType(CodeConstants.TYPE_OBJECT, 0, classname);
+          VarType leftType = new VarType(CodeConstants.Type.OBJECT, 0, classname);
 
           if (rightType.equals(VarType.VARTYPE_OBJECT) && !leftType.equals(rightType)) {
             buf.append("((").append(ExprProcessor.getCastTypeName(leftType)).append(")");
@@ -441,7 +441,7 @@ public class InvocationExprent extends Exprent {
         Exprent value = inv.lstParameters.get(0);
         types[i] = value.getExprType(); //Infer?
         //Unboxing in this case is lossy, so we need to explicitly set the type
-        if (types[i] .typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
+        if (types[i] .typeFamily == CodeConstants.TypeFamily.INTEGER) {
           types[i] =
               "java/lang/Short".equals(inv.classname) ? VarType.VARTYPE_SHORT :
               "java/lang/Byte".equals(inv.classname) ? VarType.VARTYPE_BYTE :
@@ -527,7 +527,7 @@ public class InvocationExprent extends Exprent {
 
         // not passing it along if what we get back is more specific
         VarType exprType = lstParameters.get(i).getInferredExprType(type);
-        if (exprType != null && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+        if (exprType != null && type != null && type.type == CodeConstants.Type.GENVAR) {
           //type = exprType;
         }
         */
@@ -584,27 +584,27 @@ public class InvocationExprent extends Exprent {
 
   private boolean isBoxingCall() {
     if (isStatic && "valueOf".equals(name) && lstParameters.size() == 1) {
-      int paramType = lstParameters.get(0).getExprType().type;
+      CodeConstants.Type paramType = lstParameters.get(0).getExprType().type;
 
       // special handling for ambiguous types
       if (lstParameters.get(0).type == Exprent.EXPRENT_CONST) {
         // 'Integer.valueOf(1)' has '1' type detected as TYPE_BYTECHAR
         // 'Integer.valueOf(40_000)' has '40_000' type detected as TYPE_CHAR
         // so we check the type family instead
-        if (lstParameters.get(0).getExprType().typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
+        if (lstParameters.get(0).getExprType().typeFamily == CodeConstants.TypeFamily.INTEGER) {
           if (classname.equals("java/lang/Integer")) {
             return true;
           }
         }
 
-        if (paramType == CodeConstants.TYPE_BYTECHAR || paramType == CodeConstants.TYPE_SHORTCHAR) {
+        if (paramType == CodeConstants.Type.BYTECHAR || paramType == CodeConstants.Type.SHORTCHAR) {
           if (classname.equals("java/lang/Character") || classname.equals("java/lang/Short")) {
             return true;
           }
         }
       }
 
-      return classname.equals(getClassNameForPrimitiveType(paramType));
+      return classname.equals(paramType.getBoxedClass());
     }
 
     return false;
@@ -614,31 +614,6 @@ public class InvocationExprent extends Exprent {
     canIgnoreBoxing = false;
   }
 
-  // TODO: move to CodeConstants ???
-  private static String getClassNameForPrimitiveType(int type) {
-    switch (type) {
-      case CodeConstants.TYPE_BOOLEAN:
-        return "java/lang/Boolean";
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_BYTECHAR:
-        return "java/lang/Byte";
-      case CodeConstants.TYPE_CHAR:
-        return "java/lang/Character";
-      case CodeConstants.TYPE_SHORT:
-      case CodeConstants.TYPE_SHORTCHAR:
-        return "java/lang/Short";
-      case CodeConstants.TYPE_INT:
-        return "java/lang/Integer";
-      case CodeConstants.TYPE_LONG:
-        return "java/lang/Long";
-      case CodeConstants.TYPE_FLOAT:
-        return "java/lang/Float";
-      case CodeConstants.TYPE_DOUBLE:
-        return "java/lang/Double";
-    }
-    return null;
-  }
-
   private static final Map<String, String> UNBOXING_METHODS;
 
   static {
@@ -755,8 +730,8 @@ public class InvocationExprent extends Exprent {
           }
         }
         else {
-          if (md.params[i].type == CodeConstants.TYPE_OBJECT) {
-            if (ptype.type != CodeConstants.TYPE_NULL) {
+          if (md.params[i].type == CodeConstants.Type.OBJECT) {
+            if (ptype.type != CodeConstants.Type.NULL) {
               if (!DecompilerContext.getStructContext().instanceOf(ptype.value, md.params[i].value)) {
                 failed = true;
                 break;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
index 4c8bcf1..f54c0df 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
@@ -48,7 +48,7 @@ public class NewExprent extends Exprent {
 
     anonymous = false;
     lambda = false;
-    if (newType.type == CodeConstants.TYPE_OBJECT && newType.arrayDim == 0) {
+    if (newType.type == CodeConstants.Type.OBJECT && newType.arrayDim == 0) {
       ClassNode node = DecompilerContext.getClassProcessor().getMapRootClasses().get(newType.value);
       if (node != null && (node.type == ClassNode.CLASS_ANONYMOUS || node.type == ClassNode.CLASS_LAMBDA)) {
         anonymous = true;
@@ -77,7 +77,7 @@ public class NewExprent extends Exprent {
   @Override
   public VarType getInferredExprType(VarType upperBound) {
     genericArgs.clear();
-    if (newType.type == CodeConstants.TYPE_OBJECT && newType.arrayDim == 0) {
+    if (newType.type == CodeConstants.Type.OBJECT && newType.arrayDim == 0) {
       StructClass node = DecompilerContext.getStructContext().getClass(newType.value);
 
       if (node != null && node.getSignature() != null) {
@@ -343,7 +343,7 @@ public class NewExprent extends Exprent {
       // if there is just one element of Object[] type it needs to be casted to resolve ambiguity
       if (lstArrayElements.size() == 1) {
         VarType elementType = lstArrayElements.get(0).getExprType();
-        if (elementType.type == CodeConstants.TYPE_OBJECT && elementType.value.equals("java/lang/Object") && elementType.arrayDim >= 1) {
+        if (elementType.type == CodeConstants.Type.OBJECT && elementType.value.equals("java/lang/Object") && elementType.arrayDim >= 1) {
           buf.prepend("(Object)");
         }
       }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index fbd2e43..b3ae315 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -244,7 +244,7 @@ public class VarExprent extends Exprent {
       vt = processor.getVarType(getVarVersionPair());
     }
 
-    if (vt == null || (varType != null && varType.type != CodeConstants.TYPE_UNKNOWN)) {
+    if (vt == null || (varType != null && varType.type != CodeConstants.Type.UNKNOWN)) {
       vt = varType;
     }
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
index 3607a8d..e4175c7 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
@@ -256,7 +256,7 @@ public class SSAUConstructorSparseEx {
     }
     else if (expr.type == Exprent.EXPRENT_INVOCATION ||
              (expr.type == Exprent.EXPRENT_ASSIGNMENT && ((AssignmentExprent)expr).getLeft().type == Exprent.EXPRENT_FIELD) ||
-             (expr.type == Exprent.EXPRENT_NEW && ((NewExprent)expr).getNewType().type == CodeConstants.TYPE_OBJECT) ||
+             (expr.type == Exprent.EXPRENT_NEW && ((NewExprent)expr).getNewType().type == CodeConstants.Type.OBJECT) ||
              expr.type == Exprent.EXPRENT_FUNCTION) {
 
       boolean ismmpp = true;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
index e110963..d19c8b2 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
@@ -54,7 +54,7 @@ public class CatchAllStatement extends Statement {
     }
     
     vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
-                            new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Throwable"),
+                            new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Throwable"),
                             DecompilerContext.getVarProcessor()));
   }
 
@@ -168,7 +168,7 @@ public class CatchAllStatement extends Statement {
     if (!this.vars.isEmpty()) {
       // FIXME: WTF??? vars?!
       vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
-                              new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Throwable"),
+                              new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Throwable"),
                               DecompilerContext.getVarProcessor()));
     }
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
index f74fe84..d0c3962 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
@@ -45,7 +45,7 @@ public class CatchStatement extends Statement {
         exctstrings.add(new ArrayList<>(edge.getExceptions()));
         
         vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
-                                new VarType(CodeConstants.TYPE_OBJECT, 0, edge.getExceptions().get(0)),
+                                new VarType(CodeConstants.Type.OBJECT, 0, edge.getExceptions().get(0)),
                                 // FIXME: for now simply the first type. Should get the first common superclass when possible.
                                 DecompilerContext.getVarProcessor()));
       }
@@ -162,7 +162,7 @@ public class CatchStatement extends Statement {
       List<String> exception_types = exctstrings.get(i - 1);
       if (exception_types.size() > 1) { // multi-catch, Java 7 style
         for (int exc_index = 1; exc_index < exception_types.size(); ++exc_index) {
-          VarType exc_type = new VarType(CodeConstants.TYPE_OBJECT, 0, exception_types.get(exc_index));
+          VarType exc_type = new VarType(CodeConstants.Type.OBJECT, 0, exception_types.get(exc_index));
           String exc_type_name = ExprProcessor.getCastTypeName(exc_type);
 
           buf.append(exc_type_name).append(" | ");
@@ -186,7 +186,7 @@ public class CatchStatement extends Statement {
     for (List<String> exc : this.exctstrings) {
       cs.exctstrings.add(new ArrayList<>(exc));
       cs.vars.add(new VarExprent(DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER),
-                                 new VarType(CodeConstants.TYPE_OBJECT, 0, exc.get(0)),
+                                 new VarType(CodeConstants.Type.OBJECT, 0, exc.get(0)),
                                  DecompilerContext.getVarProcessor()));
     }
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 054abbb..f92429a 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -717,7 +717,7 @@ public class VarDefinitionHelper {
     if (type == null || firstMin == null || secondMin == null) {
       return null; // no common supertype, skip the remapping
     }
-    if (type.typeFamily == CodeConstants.TYPE_FAMILY_OBJECT) {
+    if (type.typeFamily == CodeConstants.TypeFamily.OBJECT) {
       if (firstMax != null && secondMax != null) {
         type = VarType.getCommonMinType(firstMax, secondMax);
       } else if (firstMin.arrayDim != secondMin.arrayDim) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
index a2f25f0..8e07067 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
@@ -51,7 +51,7 @@ public class VarTypeProcessor {
 
     if (thisVar) {
       StructClass cl = (StructClass)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS);
-      VarType clType = new VarType(CodeConstants.TYPE_OBJECT, 0, cl.qualifiedName);
+      VarType clType = new VarType(CodeConstants.Type.OBJECT, 0, cl.qualifiedName);
       mapExprentMinTypes.put(new VarVersionPair(0, 1), clType);
       mapExprentMaxTypes.put(new VarVersionPair(0, 1), clType);
     }
@@ -105,7 +105,7 @@ public class VarTypeProcessor {
         }
         else if (expr.type == Exprent.EXPRENT_CONST) {
           ConstExprent constExpr = (ConstExprent)expr;
-          if (constExpr.getConstType().typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
+          if (constExpr.getConstType().typeFamily == CodeConstants.TypeFamily.INTEGER) {
             constExpr.setConstType(new ConstExprent(constExpr.getIntValue(), constExpr.isBoolPermitted(), null).getConstType());
           }
         }
@@ -128,7 +128,8 @@ public class VarTypeProcessor {
 
     if (exprent.type == Exprent.EXPRENT_CONST) {
       ConstExprent constExpr = (ConstExprent)exprent;
-      if (constExpr.getConstType().typeFamily <= CodeConstants.TYPE_FAMILY_INTEGER) { // boolean or integer
+      if (constExpr.getConstType().typeFamily == CodeConstants.TypeFamily.INTEGER ||
+          constExpr.getConstType().typeFamily == CodeConstants.TypeFamily.BOOLEAN) {
         VarVersionPair pair = new VarVersionPair(constExpr.id, -1);
         if (!mapExprentMinTypes.containsKey(pair)) {
           mapExprentMinTypes.put(pair, constExpr.getConstType());
@@ -141,7 +142,7 @@ public class VarTypeProcessor {
     boolean res = true;
     if (result != null) {
       for (CheckTypesResult.ExprentTypePair entry : result.getLstMaxTypeExprents()) {
-        if (entry.type.typeFamily != CodeConstants.TYPE_FAMILY_OBJECT) {
+        if (entry.type.typeFamily != CodeConstants.TypeFamily.OBJECT) {
           changeExprentType(entry.exprent, entry.type, 1);
         }
       }
@@ -163,10 +164,10 @@ public class VarTypeProcessor {
         ConstExprent constExpr = (ConstExprent)exprent;
         VarType constType = constExpr.getConstType();
 
-        if (newType.typeFamily > CodeConstants.TYPE_FAMILY_INTEGER || constType.typeFamily > CodeConstants.TYPE_FAMILY_INTEGER) {
+        if (newType.typeFamily.compareTo(CodeConstants.TypeFamily.INTEGER) > 0 || constType.typeFamily.compareTo(CodeConstants.TypeFamily.INTEGER) > 0) {
           return true;
         }
-        else if (newType.typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
+        else if (newType.typeFamily == CodeConstants.TypeFamily.INTEGER) {
           VarType minInteger = new ConstExprent((Integer)constExpr.getValue(), false, null).getConstType();
           if (minInteger.isStrictSuperset(newType)) {
             newType = minInteger;
@@ -185,10 +186,10 @@ public class VarTypeProcessor {
         if (minMax == 0) { // min
           VarType currentMinType = mapExprentMinTypes.get(pair);
           VarType newMinType;
-          if (currentMinType == null || newType.typeFamily > currentMinType.typeFamily) {
+          if (currentMinType == null || newType.typeFamily.compareTo(currentMinType.typeFamily) > 0) {
             newMinType = newType;
           }
-          else if (newType.typeFamily < currentMinType.typeFamily) {
+          else if (newType.typeFamily.compareTo(currentMinType.typeFamily) < 0) {
             return true;
           }
           else {
@@ -201,17 +202,17 @@ public class VarTypeProcessor {
             ((ConstExprent)exprent).setConstType(newMinType);
           }
 
-          if (currentMinType != null && (newMinType.typeFamily > currentMinType.typeFamily || newMinType.isStrictSuperset(currentMinType))) {
+          if (currentMinType != null && (newMinType.typeFamily.compareTo(currentMinType.typeFamily) > 0 || newMinType.isStrictSuperset(currentMinType))) {
             return false;
           }
         }
         else {  // max
           VarType currentMaxType = mapExprentMaxTypes.get(pair);
           VarType newMaxType;
-          if (currentMaxType == null || newType.typeFamily < currentMaxType.typeFamily) {
+          if (currentMaxType == null || newType.typeFamily.compareTo(currentMaxType.typeFamily) < 0) {
             newMaxType = newType;
           }
-          else if (newType.typeFamily > currentMaxType.typeFamily) {
+          else if (newType.typeFamily.compareTo(currentMaxType.typeFamily) > 0) {
             return true;
           }
           else {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
index 47e7e0c..486f464 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
@@ -120,18 +120,18 @@ public class VarVersionsProcessor {
       VarType type = mapExprentMinTypes.get(paar);
       VarType maxType = mapExprentMaxTypes.get(paar);
 
-      if (type.type == CodeConstants.TYPE_BYTECHAR || type.type == CodeConstants.TYPE_SHORTCHAR) {
-        if (maxType != null && maxType.type == CodeConstants.TYPE_CHAR) {
+      if (type.type == CodeConstants.Type.BYTECHAR || type.type == CodeConstants.Type.SHORTCHAR) {
+        if (maxType != null && maxType.type == CodeConstants.Type.CHAR) {
           type = VarType.VARTYPE_CHAR;
         }
         else {
-          type = type.type == CodeConstants.TYPE_BYTECHAR ? VarType.VARTYPE_BYTE : VarType.VARTYPE_SHORT;
+          type = type.type == CodeConstants.Type.BYTECHAR ? VarType.VARTYPE_BYTE : VarType.VARTYPE_SHORT;
         }
         mapExprentMinTypes.put(paar, type);
-        //} else if(type.type == CodeConstants.TYPE_CHAR && (maxType == null || maxType.type == CodeConstants.TYPE_INT)) { // when possible, lift char to int
+        //} else if(type.type == CodeConstants.Type.CHAR && (maxType == null || maxType.type == CodeConstants.Type.INT)) { // when possible, lift char to int
         //	mapExprentMinTypes.put(paar, VarType.VARTYPE_INT);
       }
-      else if (type.type == CodeConstants.TYPE_NULL) {
+      else if (type.type == CodeConstants.Type.NULL) {
         mapExprentMinTypes.put(paar, VarType.VARTYPE_OBJECT);
       }
     }
@@ -172,8 +172,8 @@ public class VarVersionsProcessor {
             VarType secondType = mapExprentMinTypes.get(secondPair);
 
             if (firstType.equals(secondType) ||
-                (firstType.equals(VarType.VARTYPE_NULL) && secondType.type == CodeConstants.TYPE_OBJECT) ||
-                (secondType.equals(VarType.VARTYPE_NULL) && firstType.type == CodeConstants.TYPE_OBJECT)) {
+                (firstType.equals(VarType.VARTYPE_NULL) && secondType.type == CodeConstants.Type.OBJECT) ||
+                (secondType.equals(VarType.VARTYPE_NULL) && firstType.type == CodeConstants.Type.OBJECT)) {
 
               VarType firstMaxType = mapExprentMaxTypes.get(firstPair);
               VarType secondMaxType = mapExprentMaxTypes.get(secondPair);
diff --git a/src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationAttribute.java b/src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationAttribute.java
index dec6b28..1602c24 100644
--- a/src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationAttribute.java
+++ b/src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationAttribute.java
@@ -75,34 +75,34 @@ public class StructAnnotationAttribute extends StructGeneralAttribute {
 
         String value;
         switch (type.type) {
-          case CodeConstants.TYPE_OBJECT:
+          case OBJECT:
             value = type.value;
             break;
-          case CodeConstants.TYPE_BYTE:
+          case BYTE:
             value = byte.class.getName();
             break;
-          case CodeConstants.TYPE_CHAR:
+          case CHAR:
             value = char.class.getName();
             break;
-          case CodeConstants.TYPE_DOUBLE:
+          case DOUBLE:
             value = double.class.getName();
             break;
-          case CodeConstants.TYPE_FLOAT:
+          case FLOAT:
             value = float.class.getName();
             break;
-          case CodeConstants.TYPE_INT:
+          case INT:
             value = int.class.getName();
             break;
-          case CodeConstants.TYPE_LONG:
+          case LONG:
             value = long.class.getName();
             break;
-          case CodeConstants.TYPE_SHORT:
+          case SHORT:
             value = short.class.getName();
             break;
-          case CodeConstants.TYPE_BOOLEAN:
+          case BOOLEAN:
             value = boolean.class.getName();
             break;
-          case CodeConstants.TYPE_VOID:
+          case VOID:
             value = void.class.getName();
             break;
           default:
@@ -122,7 +122,7 @@ public class StructAnnotationAttribute extends StructGeneralAttribute {
 
         VarType newType;
         if (elements.isEmpty()) {
-          newType = new VarType(CodeConstants.TYPE_OBJECT, 1, "java/lang/Object");
+          newType = new VarType(CodeConstants.Type.OBJECT, 1, "java/lang/Object");
         }
         else {
           VarType elementType = elements.get(0).getExprType();
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java b/src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
index f3d8562..02e7eb1 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
@@ -18,7 +18,7 @@ public class DataPoint {
   public void setVariable(int index, VarType value) {
     if (index >= localVariables.size()) {
       for (int i = localVariables.size(); i <= index; i++) {
-        localVariables.add(new VarType(CodeConstants.TYPE_NOTINITIALIZED));
+        localVariables.add(new VarType(CodeConstants.Type.NOTINITIALIZED));
       }
     }
 
@@ -30,7 +30,7 @@ public class DataPoint {
       return localVariables.get(index);
     }
     else {
-      return new VarType(CodeConstants.TYPE_NOTINITIALIZED);
+      return new VarType(CodeConstants.Type.NOTINITIALIZED);
     }
   }
 
@@ -49,7 +49,7 @@ public class DataPoint {
 
     int k = 0;
     if (!mt.hasModifier(CodeConstants.ACC_STATIC)) {
-      point.setVariable(k++, new VarType(CodeConstants.TYPE_OBJECT, 0, null));
+      point.setVariable(k++, new VarType(CodeConstants.Type.OBJECT, 0, null));
     }
 
     for (int i = 0; i < md.params.length; i++) {
@@ -57,7 +57,7 @@ public class DataPoint {
 
       point.setVariable(k++, var);
       if (var.stackSize == 2) {
-        point.setVariable(k++, new VarType(CodeConstants.TYPE_GROUP2EMPTY));
+        point.setVariable(k++, new VarType(CodeConstants.Type.GROUP2EMPTY));
       }
     }
 
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
index 765820c..0b435cc 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
@@ -23,7 +23,7 @@ public class FieldDescriptor {
   }
 
   public String buildNewDescriptor(NewClassNameBuilder builder) {
-    if (type.type == CodeConstants.TYPE_OBJECT) {
+    if (type.type == CodeConstants.Type.OBJECT) {
       String newClassName = builder.buildNewClassname(type.value);
       if (newClassName != null) {
         return new VarType(type.type, type.arrayDim, newClassName).toString();
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
index 5304ddc..1b2cf33 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
@@ -143,7 +143,7 @@ public class MethodDescriptor {
   }
 
   private static VarType buildNewType(VarType type, NewClassNameBuilder builder) {
-    if (type.type == CodeConstants.TYPE_OBJECT) {
+    if (type.type == CodeConstants.Type.OBJECT) {
       String newClassName = builder.buildNewClassname(type.value);
       if (newClassName != null) {
         return new VarType(type.type, type.arrayDim, newClassName);
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
index 48d49e6..53bbcdb 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
@@ -4,55 +4,54 @@ package org.jetbrains.java.decompiler.struct.gen;
 import java.util.Map;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 public class VarType {  // TODO: optimize switch
 
   public static final VarType[] EMPTY_ARRAY = {};
 
-  public static final VarType VARTYPE_UNKNOWN = new VarType(CodeConstants.TYPE_UNKNOWN);
-  public static final VarType VARTYPE_INT = new VarType(CodeConstants.TYPE_INT);
-  public static final VarType VARTYPE_FLOAT = new VarType(CodeConstants.TYPE_FLOAT);
-  public static final VarType VARTYPE_LONG = new VarType(CodeConstants.TYPE_LONG);
-  public static final VarType VARTYPE_DOUBLE = new VarType(CodeConstants.TYPE_DOUBLE);
-  public static final VarType VARTYPE_BYTE = new VarType(CodeConstants.TYPE_BYTE);
-  public static final VarType VARTYPE_CHAR = new VarType(CodeConstants.TYPE_CHAR);
-  public static final VarType VARTYPE_SHORT = new VarType(CodeConstants.TYPE_SHORT);
-  public static final VarType VARTYPE_BOOLEAN = new VarType(CodeConstants.TYPE_BOOLEAN);
-  public static final VarType VARTYPE_BYTECHAR = new VarType(CodeConstants.TYPE_BYTECHAR);
-  public static final VarType VARTYPE_SHORTCHAR = new VarType(CodeConstants.TYPE_SHORTCHAR);
-
-  public static final VarType VARTYPE_NULL = new VarType(CodeConstants.TYPE_NULL, 0, null);
-  public static final VarType VARTYPE_STRING = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/String");
-  public static final VarType VARTYPE_CLASS = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Class");
-  public static final VarType VARTYPE_OBJECT = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Object");
-  public static final VarType VARTYPE_INTEGER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Integer");
-  public static final VarType VARTYPE_CHARACTER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Character");
-  public static final VarType VARTYPE_BYTE_OBJ = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Byte");
-  public static final VarType VARTYPE_SHORT_OBJ = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Short");
-  public static final VarType VARTYPE_VOID = new VarType(CodeConstants.TYPE_VOID);
-
-  public final int type;
+  public static final VarType VARTYPE_UNKNOWN = new VarType(CodeConstants.Type.UNKNOWN);
+  public static final VarType VARTYPE_INT = new VarType(CodeConstants.Type.INT);
+  public static final VarType VARTYPE_FLOAT = new VarType(CodeConstants.Type.FLOAT);
+  public static final VarType VARTYPE_LONG = new VarType(CodeConstants.Type.LONG);
+  public static final VarType VARTYPE_DOUBLE = new VarType(CodeConstants.Type.DOUBLE);
+  public static final VarType VARTYPE_BYTE = new VarType(CodeConstants.Type.BYTE);
+  public static final VarType VARTYPE_CHAR = new VarType(CodeConstants.Type.CHAR);
+  public static final VarType VARTYPE_SHORT = new VarType(CodeConstants.Type.SHORT);
+  public static final VarType VARTYPE_BOOLEAN = new VarType(CodeConstants.Type.BOOLEAN);
+  public static final VarType VARTYPE_BYTECHAR = new VarType(CodeConstants.Type.BYTECHAR);
+  public static final VarType VARTYPE_SHORTCHAR = new VarType(CodeConstants.Type.SHORTCHAR);
+
+  public static final VarType VARTYPE_NULL = new VarType(CodeConstants.Type.NULL, 0, null);
+  public static final VarType VARTYPE_STRING = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/String");
+  public static final VarType VARTYPE_CLASS = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Class");
+  public static final VarType VARTYPE_OBJECT = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Object");
+  public static final VarType VARTYPE_INTEGER = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Integer");
+  public static final VarType VARTYPE_CHARACTER = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Character");
+  public static final VarType VARTYPE_BYTE_OBJ = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Byte");
+  public static final VarType VARTYPE_SHORT_OBJ = new VarType(CodeConstants.Type.OBJECT, 0, "java/lang/Short");
+  public static final VarType VARTYPE_VOID = new VarType(CodeConstants.Type.VOID);
+
+  public final CodeConstants.Type type;
   public final int arrayDim;
   public final String value;
-  public final int typeFamily;
+  public final CodeConstants.TypeFamily typeFamily;
   public final int stackSize;
   public final boolean falseBoolean;
 
-  public VarType(int type) {
+  public VarType(CodeConstants.Type type) {
     this(type, 0);
   }
 
-  public VarType(int type, int arrayDim) {
+  public VarType(CodeConstants.Type type, int arrayDim) {
     this(type, arrayDim, getChar(type));
   }
 
-  public VarType(int type, int arrayDim, String value) {
+  public VarType(CodeConstants.Type type, int arrayDim, String value) {
     this(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
   }
 
-  protected VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
+  protected VarType(CodeConstants.Type type, int arrayDim, String value, CodeConstants.TypeFamily typeFamily, int stackSize, boolean falseBoolean) {
     this.type = type;
     this.arrayDim = arrayDim;
     this.value = value;
@@ -66,7 +65,7 @@ public class VarType {  // TODO: optimize switch
   }
 
   public VarType(String signature, boolean clType) {
-    int type = 0;
+    CodeConstants.Type type = CodeConstants.Type.UNKNOWN;
     int arrayDim = 0;
     String value = null;
 
@@ -79,7 +78,7 @@ public class VarType {  // TODO: optimize switch
 
         case 'L':
           if (signature.charAt(signature.length() - 1) == ';') {
-            type = CodeConstants.TYPE_OBJECT;
+            type = CodeConstants.Type.OBJECT;
             value = signature.substring(i + 1, signature.length() - 1);
             break loop;
           }
@@ -87,7 +86,7 @@ public class VarType {  // TODO: optimize switch
         default:
           value = signature.substring(i, signature.length());
           if ((clType && i == 0) || value.length() > 1) {
-            type = CodeConstants.TYPE_OBJECT;
+            type = CodeConstants.Type.OBJECT;
           }
           else {
             type = getType(value.charAt(0));
@@ -96,6 +95,10 @@ public class VarType {  // TODO: optimize switch
       }
     }
 
+    if (type == CodeConstants.Type.UNKNOWN) {
+      throw new IllegalArgumentException("Bad signature " + signature);
+    }
+
     this.type = type;
     this.arrayDim = arrayDim;
     this.value = value;
@@ -104,90 +107,33 @@ public class VarType {  // TODO: optimize switch
     this.falseBoolean = false;
   }
 
-  private static String getChar(int type) {
-    switch (type) {
-      case CodeConstants.TYPE_BYTE:
-        return "B";
-      case CodeConstants.TYPE_CHAR:
-        return "C";
-      case CodeConstants.TYPE_DOUBLE:
-        return "D";
-      case CodeConstants.TYPE_FLOAT:
-        return "F";
-      case CodeConstants.TYPE_INT:
-        return "I";
-      case CodeConstants.TYPE_LONG:
-        return "J";
-      case CodeConstants.TYPE_SHORT:
-        return "S";
-      case CodeConstants.TYPE_BOOLEAN:
-        return "Z";
-      case CodeConstants.TYPE_VOID:
-        return "V";
-      case CodeConstants.TYPE_GROUP2EMPTY:
-        return "G";
-      case CodeConstants.TYPE_NOTINITIALIZED:
-        return "N";
-      case CodeConstants.TYPE_ADDRESS:
-        return "A";
-      case CodeConstants.TYPE_BYTECHAR:
-        return "X";
-      case CodeConstants.TYPE_SHORTCHAR:
-        return "Y";
-      case CodeConstants.TYPE_UNKNOWN:
-        return "U";
-      case CodeConstants.TYPE_NULL:
-      case CodeConstants.TYPE_OBJECT:
-        return null;
-      default:
-        throw new RuntimeException("Invalid type");
-    }
+  private static String getChar(CodeConstants.Type type) {
+    return type.getDescriptor();
   }
 
-  protected static int getStackSize(int type, int arrayDim) {
+  protected static int getStackSize(CodeConstants.Type type, int arrayDim) {
     if (arrayDim > 0) {
       return 1;
     }
 
     switch (type) {
-      case CodeConstants.TYPE_DOUBLE:
-      case CodeConstants.TYPE_LONG:
+      case DOUBLE:
+      case LONG:
         return 2;
-      case CodeConstants.TYPE_VOID:
-      case CodeConstants.TYPE_GROUP2EMPTY:
+      case VOID:
+      case GROUP2EMPTY:
         return 0;
       default:
-        return 1;
+       return 1;
     }
   }
 
-  protected static int getFamily(int type, int arrayDim) {
+  protected static CodeConstants.TypeFamily getFamily(CodeConstants.Type type, int arrayDim) {
     if (arrayDim > 0) {
-      return CodeConstants.TYPE_FAMILY_OBJECT;
+      return CodeConstants.TypeFamily.OBJECT;
     }
 
-    switch (type) {
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_BYTECHAR:
-      case CodeConstants.TYPE_SHORTCHAR:
-      case CodeConstants.TYPE_CHAR:
-      case CodeConstants.TYPE_SHORT:
-      case CodeConstants.TYPE_INT:
-        return CodeConstants.TYPE_FAMILY_INTEGER;
-      case CodeConstants.TYPE_DOUBLE:
-        return CodeConstants.TYPE_FAMILY_DOUBLE;
-      case CodeConstants.TYPE_FLOAT:
-        return CodeConstants.TYPE_FAMILY_FLOAT;
-      case CodeConstants.TYPE_LONG:
-        return CodeConstants.TYPE_FAMILY_LONG;
-      case CodeConstants.TYPE_BOOLEAN:
-        return CodeConstants.TYPE_FAMILY_BOOLEAN;
-      case CodeConstants.TYPE_NULL:
-      case CodeConstants.TYPE_OBJECT:
-        return CodeConstants.TYPE_FAMILY_OBJECT;
-      default:
-        return CodeConstants.TYPE_FAMILY_UNKNOWN;
-    }
+    return type.getFamily();
   }
 
   public VarType decreaseArrayDim() {
@@ -221,9 +167,9 @@ public class VarType {  // TODO: optimize switch
   }
 
   public boolean isStrictSuperset(VarType val) {
-    int valType = val.type;
+    CodeConstants.Type valType = val.type;
 
-    if (valType == CodeConstants.TYPE_UNKNOWN && type != CodeConstants.TYPE_UNKNOWN) {
+    if (valType == CodeConstants.Type.UNKNOWN && type != CodeConstants.Type.UNKNOWN) {
       return true;
     }
 
@@ -231,32 +177,35 @@ public class VarType {  // TODO: optimize switch
       return this.equals(VARTYPE_OBJECT);
     }
     else if (arrayDim > 0) {
-      return (valType == CodeConstants.TYPE_NULL);
+      return (valType == CodeConstants.Type.NULL);
     }
 
     boolean res = false;
 
     switch (type) {
-      case CodeConstants.TYPE_INT:
-        res = (valType == CodeConstants.TYPE_SHORT || valType == CodeConstants.TYPE_CHAR);
-      case CodeConstants.TYPE_SHORT:
-        res |= (valType == CodeConstants.TYPE_BYTE);
-      case CodeConstants.TYPE_CHAR:
-        res |= (valType == CodeConstants.TYPE_SHORTCHAR);
-      case CodeConstants.TYPE_BYTE:
-      case CodeConstants.TYPE_SHORTCHAR:
-        res |= (valType == CodeConstants.TYPE_BYTECHAR);
-      case CodeConstants.TYPE_BYTECHAR:
-        res |= (valType == CodeConstants.TYPE_BOOLEAN);
+      case INT:
+        res = (valType == CodeConstants.Type.SHORT || valType == CodeConstants.Type.CHAR);
+      case SHORT:
+        res |= (valType == CodeConstants.Type.BYTE);
+      case CHAR:
+        res |= (valType == CodeConstants.Type.SHORTCHAR);
+      case BYTE:
+      case SHORTCHAR:
+        res |= (valType == CodeConstants.Type.BYTECHAR);
+      case BYTECHAR:
+        res |= (valType == CodeConstants.Type.BOOLEAN);
         break;
 
-      case CodeConstants.TYPE_OBJECT:
-        if (valType == CodeConstants.TYPE_NULL) {
+      case OBJECT:
+        if (valType == CodeConstants.Type.NULL) {
           return true;
         }
         else if (this.equals(VARTYPE_OBJECT)) {
-          return valType == CodeConstants.TYPE_OBJECT && !val.equals(VARTYPE_OBJECT);
+          return valType == CodeConstants.Type.OBJECT && !val.equals(VARTYPE_OBJECT);
         }
+
+      default:
+        return false;
     }
 
     return res;
@@ -265,7 +214,7 @@ public class VarType {  // TODO: optimize switch
   @Override
   public int hashCode() {
     int result = 1;
-    result = 37 * result + type;
+    result = 37 * result + type.hashCode();
     result = 37 * result + arrayDim;
     result = 37 * result + (value == null ? 0 : value.hashCode());
     return result;
@@ -291,7 +240,7 @@ public class VarType {  // TODO: optimize switch
     for (int i = 0; i < arrayDim; i++) {
       res.append('[');
     }
-    if (type == CodeConstants.TYPE_OBJECT) {
+    if (type == CodeConstants.Type.OBJECT) {
       res.append('L').append(value).append(';');
     }
     else {
@@ -302,7 +251,7 @@ public class VarType {  // TODO: optimize switch
 
   // type1 and type2 must not be null
   public static VarType getCommonMinType(VarType type1, VarType type2) {
-    if (type1.type == CodeConstants.TYPE_BOOLEAN && type2.type == CodeConstants.TYPE_BOOLEAN) { // special case booleans
+    if (type1.type == CodeConstants.Type.BOOLEAN && type2.type == CodeConstants.Type.BOOLEAN) { // special case booleans
       return type1.isFalseBoolean() ? type2 : type1;
     }
 
@@ -314,16 +263,17 @@ public class VarType {  // TODO: optimize switch
     }
     else if (type1.typeFamily == type2.typeFamily) {
       switch (type1.typeFamily) {
-        case CodeConstants.TYPE_FAMILY_INTEGER:
-          if ((type1.type == CodeConstants.TYPE_CHAR && type2.type == CodeConstants.TYPE_SHORT)
-              || (type1.type == CodeConstants.TYPE_SHORT && type2.type == CodeConstants.TYPE_CHAR)) {
+        case INTEGER:
+          if ((type1.type == CodeConstants.Type.CHAR && type2.type == CodeConstants.Type.SHORT)
+              || (type1.type == CodeConstants.Type.SHORT && type2.type == CodeConstants.Type.CHAR)) {
             return VARTYPE_SHORTCHAR;
           }
           else {
             return VARTYPE_BYTECHAR;
           }
-        case CodeConstants.TYPE_FAMILY_OBJECT:
+        case OBJECT:
           return VARTYPE_NULL;
+        default:
       }
     }
 
@@ -332,7 +282,7 @@ public class VarType {  // TODO: optimize switch
 
   // type1 and type2 must not be null
   public static VarType getCommonSupertype(VarType type1, VarType type2) {
-    if (type1.type == CodeConstants.TYPE_BOOLEAN && type2.type == CodeConstants.TYPE_BOOLEAN) { // special case booleans
+    if (type1.type == CodeConstants.Type.BOOLEAN && type2.type == CodeConstants.Type.BOOLEAN) { // special case booleans
       return type1.isFalseBoolean() ? type1 : type2;
     }
 
@@ -344,78 +294,46 @@ public class VarType {  // TODO: optimize switch
     }
     else if (type1.typeFamily == type2.typeFamily) {
       switch (type1.typeFamily) {
-        case CodeConstants.TYPE_FAMILY_INTEGER:
-          if ((type1.type == CodeConstants.TYPE_SHORTCHAR && type2.type == CodeConstants.TYPE_BYTE)
-              || (type1.type == CodeConstants.TYPE_BYTE && type2.type == CodeConstants.TYPE_SHORTCHAR)) {
+        case INTEGER:
+          if ((type1.type == CodeConstants.Type.SHORTCHAR && type2.type == CodeConstants.Type.BYTE)
+              || (type1.type == CodeConstants.Type.BYTE && type2.type == CodeConstants.Type.SHORTCHAR)) {
             return VARTYPE_SHORT;
           }
           else {
             return VARTYPE_INT;
           }
-        case CodeConstants.TYPE_FAMILY_OBJECT:
+        case OBJECT:
           return VARTYPE_OBJECT;
+        default:
       }
     }
 
     return null;
   }
 
-  public static VarType getMinTypeInFamily(int family) {
+  public static VarType getMinTypeInFamily(CodeConstants.TypeFamily family) {
     switch (family) {
-      case CodeConstants.TYPE_FAMILY_BOOLEAN:
+      case BOOLEAN:
         return VARTYPE_BOOLEAN;
-      case CodeConstants.TYPE_FAMILY_INTEGER:
+      case INTEGER:
         return VARTYPE_BYTECHAR;
-      case CodeConstants.TYPE_FAMILY_OBJECT:
+      case OBJECT:
         return VARTYPE_NULL;
-      case CodeConstants.TYPE_FAMILY_FLOAT:
+      case FLOAT:
         return VARTYPE_FLOAT;
-      case CodeConstants.TYPE_FAMILY_LONG:
+      case LONG:
         return VARTYPE_LONG;
-      case CodeConstants.TYPE_FAMILY_DOUBLE:
+      case DOUBLE:
         return VARTYPE_DOUBLE;
-      case CodeConstants.TYPE_FAMILY_UNKNOWN:
+      case UNKNOWN:
         return VARTYPE_UNKNOWN;
       default:
         throw new IllegalArgumentException("Invalid type family: " + family);
     }
   }
 
-  public static int getType(char c) {
-    switch (c) {
-      case 'B':
-        return CodeConstants.TYPE_BYTE;
-      case 'C':
-        return CodeConstants.TYPE_CHAR;
-      case 'D':
-        return CodeConstants.TYPE_DOUBLE;
-      case 'F':
-        return CodeConstants.TYPE_FLOAT;
-      case 'I':
-        return CodeConstants.TYPE_INT;
-      case 'J':
-        return CodeConstants.TYPE_LONG;
-      case 'S':
-        return CodeConstants.TYPE_SHORT;
-      case 'Z':
-        return CodeConstants.TYPE_BOOLEAN;
-      case 'V':
-        return CodeConstants.TYPE_VOID;
-      case 'G':
-        return CodeConstants.TYPE_GROUP2EMPTY;
-      case 'N':
-        return CodeConstants.TYPE_NOTINITIALIZED;
-      case 'A':
-        return CodeConstants.TYPE_ADDRESS;
-      case 'X':
-        return CodeConstants.TYPE_BYTECHAR;
-      case 'Y':
-        return CodeConstants.TYPE_SHORTCHAR;
-      case 'U':
-        return CodeConstants.TYPE_UNKNOWN;
-      default:
-        throw new IllegalArgumentException("Invalid type: " + c);
-    }
+  public static CodeConstants.Type getType(char c) {
+    return CodeConstants.Type.forSymbol(c);
   }
 
   public boolean isGeneric() {
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
index 1631617..9cd2dca 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
@@ -12,17 +12,6 @@ import java.util.List;
 
 public class GenericMain {
 
-  private static final String[] typeNames = {
-    "byte",
-    "char",
-    "double",
-    "float",
-    "int",
-    "long",
-    "short",
-    "boolean",
-  };
-
   public static GenericClassDescriptor parseClassSignature(String qualifiedName, String signature) {
     String original = signature;
     try {
@@ -172,17 +161,14 @@ public class GenericMain {
   }
 
   private static String getTypeName(GenericType type) {
-    int tp = type.type;
-    if (tp <= CodeConstants.TYPE_BOOLEAN) {
-      return typeNames[tp];
-    }
-    else if (tp == CodeConstants.TYPE_VOID) {
-      return "void";
+    CodeConstants.Type tp = type.type;
+    if (tp.getKeyword() != null) {
+      return tp.getKeyword();
     }
-    else if (tp == CodeConstants.TYPE_GENVAR) {
+    else if (tp == CodeConstants.Type.GENVAR) {
       return type.value;
     }
-    else if (tp == CodeConstants.TYPE_OBJECT) {
+    else if (tp == CodeConstants.Type.OBJECT) {
       return type.getCastName();
     }
 
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index 9dc9d81..2945be3 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -13,16 +13,18 @@ import java.util.Map;
 
 public class GenericType extends VarType {
 
-  public static final int WILDCARD_EXTENDS = 1;
-  public static final int WILDCARD_SUPER = 2;
-  public static final int WILDCARD_UNBOUND = 3;
-  public static final int WILDCARD_NO = 4;
+  public enum Wildcard {
+    EXTENDS,
+    SUPER,
+    UNBOUND,
+    NONE
+  }
 
   private final VarType parent;
   private final List<VarType> arguments;
-  private final int wildcard;
+  private final Wildcard wildcard;
 
-  public GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
+  public GenericType(CodeConstants.Type type, int arrayDim, String value, VarType parent, List<VarType> arguments, Wildcard wildcard) {
     super(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
     this.parent = parent;
     this.arguments = arguments == null ? Collections.<VarType>emptyList() : arguments;
@@ -30,11 +32,11 @@ public class GenericType extends VarType {
   }
 
   public static VarType parse(String signature) {
-    return parse(signature, WILDCARD_NO);
+    return parse(signature, Wildcard.NONE);
   }
 
-  public static VarType parse(String signature, int wildcard) {
-    int type = 0;
+  public static VarType parse(String signature, Wildcard wildcard) {
+    CodeConstants.Type type = CodeConstants.Type.UNKNOWN;
     int arrayDim = 0;
     String value = null;
     List<VarType> params = null;
@@ -49,12 +51,12 @@ public class GenericType extends VarType {
           break;
 
         case 'T':
-          type = CodeConstants.TYPE_GENVAR;
+          type = CodeConstants.Type.GENVAR;
           value = signature.substring(index + 1, signature.length() - 1);
           break loop;
 
         case 'L':
-          type = CodeConstants.TYPE_OBJECT;
+          type = CodeConstants.Type.OBJECT;
           signature = signature.substring(index + 1, signature.length() - 1);
           String cl = getNextClassSignature(signature);
 
@@ -96,7 +98,7 @@ public class GenericType extends VarType {
                   parent = GenericType.parse("L" + value + ";");
                 }
                 else {
-                  parent = new GenericType(CodeConstants.TYPE_OBJECT, 0, value, parent, params, wildcard);
+                  parent = new GenericType(CodeConstants.Type.OBJECT, 0, value, parent, params, wildcard);
                 }
 
                 signature = signature.substring(cl.length() + 1);
@@ -114,11 +116,15 @@ public class GenericType extends VarType {
       index++;
     }
 
-    if (type == CodeConstants.TYPE_GENVAR) {
+    if (type == CodeConstants.Type.UNKNOWN) {
+      throw new IllegalArgumentException("Bad signature " + signature);
+    }
+
+    if (type == CodeConstants.Type.GENVAR) {
       return new GenericType(type, arrayDim, value, null, null, wildcard);
     }
-    else if (type == CodeConstants.TYPE_OBJECT) {
-      if (parent == null && params == null && wildcard == WILDCARD_NO) {
+    else if (type == CodeConstants.Type.OBJECT) {
+      if (parent == null && params == null && wildcard == Wildcard.NONE) {
         return new VarType(type, arrayDim, value);
       }
       else {
@@ -165,21 +171,21 @@ public class GenericType extends VarType {
     while (value.length() > 0) {
       String typeStr = getNextType(value);
       int len = typeStr.length();
-      int wildcard = WILDCARD_NO;
+      Wildcard wildcard = Wildcard.NONE;
 
       switch (typeStr.charAt(0)) {
         case '*':
-          wildcard = WILDCARD_UNBOUND;
+          wildcard = Wildcard.UNBOUND;
           break;
         case '+':
-          wildcard = WILDCARD_EXTENDS;
+          wildcard = Wildcard.EXTENDS;
           break;
         case '-':
-          wildcard = WILDCARD_SUPER;
+          wildcard = Wildcard.SUPER;
           break;
       }
 
-      if (wildcard != WILDCARD_NO) {
+      if (wildcard != Wildcard.NONE) {
         typeStr = typeStr.substring(1);
       }
 
@@ -258,7 +264,7 @@ public class GenericType extends VarType {
     return true;
   }
 
-  public int getWildcard() {
+  public Wildcard getWildcard() {
     return wildcard;
   }
 
@@ -293,12 +299,13 @@ public class GenericType extends VarType {
         else if (par.isGeneric()) {
           GenericType gen = (GenericType)par;
           switch (gen.getWildcard()) {
-            case GenericType.WILDCARD_EXTENDS:
+            case EXTENDS:
               buffer.append("? extends ");
               break;
-            case GenericType.WILDCARD_SUPER:
+            case SUPER:
               buffer.append("? super ");
               break;
+            default:
           }
           buffer.append(GenericMain.getGenericCastTypeName(gen));
         }
@@ -316,12 +323,13 @@ public class GenericType extends VarType {
   public String toString() {
     StringBuilder buf = new StringBuilder();
     switch(getWildcard()) {
-      case GenericType.WILDCARD_EXTENDS:
+      case EXTENDS:
         buf.append("? extends ");
         break;
-      case GenericType.WILDCARD_SUPER:
+      case SUPER:
         buf.append("? super ");
-      break;
+        break;
+      default:
     }
     buf.append(super.toString());
     buf.append(getTypeArguments());
-- 
2.17.0

